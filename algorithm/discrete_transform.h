//-----------------------------------------------------------------------------
//  Copyright (C) 2025, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#pragma once

#include <vector>
#include <tuple>
#include <complex>
#include <algorithm>
#include <cmath>
#include <numbers>
#include <ranges>
#include "../util/gberror.h"

namespace gb::yadro::algorithm
{
    // recursive implementation of the Fast Fourier Transform
    inline void fft_recursive(std::vector<std::complex<double>>& a) 
    {
        size_t N = a.size();
        if (N <= 1) return;

        std::vector<std::complex<double>> even(N / 2), odd(N / 2);
        for (size_t i = 0; i < N / 2; ++i) 
        {
            even[i] = a[i * 2];
            odd[i] = a[i * 2 + 1];
        }

        fft_recursive(even);
        fft_recursive(odd);

        for (size_t k = 0; k < N / 2; ++k) 
        {
            std::complex<double> t = std::polar(1.0, -2 * std::numbers::pi * k / N) * odd[k];
            a[k] = even[k] + t;
            a[k + N / 2] = even[k] - t;
        }
    }

    // Decompose a signal into its frequency components using the Fast Fourier Transform
    // Returns a vector of tuples, each containing the magnitude, frequency, and phase of a component
    // The components are sorted by magnitude in descending order
    // The frequency is normalized to the range [0, 1], where 1 corresponds to the Nyquist frequency
    // The phase is in radians
    // The input data must have a size that is a power of 2
    template <std::ranges::sized_range Sequence>
    std::vector<std::tuple<double, double, double>> fft_decompose(const Sequence& data)
    {
        static_assert(std::is_convertible_v<std::ranges::range_value_t<Sequence>, double>, "Data must be convertible to double");
        size_t data_size = data.size();
        util::gbassert(data_size != 0, "data must not be empty");
        util::gbassert((data_size & (data_size - 1)) == 0, "Data size must be a power of 2");

        std::vector<std::complex<double>> x(data_size);
        for (size_t i = 0; i < data_size; ++i) {
            x[i] = std::complex<double>(data[i], 0.0);
        }

        fft_recursive(x);

        // Store only positive frequency components
        std::vector<std::tuple<double, double, double>> components;
        for (size_t k = 0; k <= data_size / 2; ++k) {
            // negative frequencies are discarded, positive frequencies are doubled
            auto magnitude = (k == 0 ? 1 : 2) * std::abs(x[k]) / data_size;
            auto frequency = static_cast<double>(k) / data_size;
            auto phase = std::atan2(x[k].imag(), x[k].real());
            components.emplace_back(magnitude, frequency, phase);
        }

        // Sort components by magnitude in descending order
        std::sort(components.begin(), components.end(), [](auto a, auto b) { return std::get<0>(a) > std::get<0>(b); });

        return components;
    }
}
