//-----------------------------------------------------------------------------
//  Copyright (C) 2025, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#pragma once

#include <cmath>
#include <ranges>
#include <algorithm>
#include <utility>
#include <stdexcept>
#include <limits>
#include <iostream>
#include <iterator>
#include <vector>
#include "../util/gberror.h"

namespace gb::yadro::algorithm
{
    // calculate error bands using Student's t-distribution

    struct student_t {
        // Constructor takes a range (e.g., vector) and a confidence level
        student_t(const std::ranges::sized_range auto& data, double confidence_level)
        {
            static_assert(std::is_floating_point_v<std::ranges::range_value_t<decltype(data)>>);
            util::gbassert(confidence_level > 0.0 && confidence_level < 1.0, "confidence_level must be in (0, 1)");
            util::gbassert(data.size() >= 2, "Data must contain at least two values.");

            auto n = static_cast<int>(data.size());

            // Compute sample mean
            auto sum = std::accumulate(data.begin(), data.end(), 0.0);
            auto mean = sum / n;

            // Compute sample standard deviation
            double sq_sum = std::inner_product(data.begin(), data.end(), data.begin(), 0.0);
            auto stddev = std::sqrt((sq_sum - n * mean * mean) / (n - 1));

            mean_pair_ = std::pair{ mean, calc_mean_margin(stddev, confidence_level, n) };
            stddev_pair_ = std::pair{ stddev, calc_stddev_margin(stddev, confidence_level, n) };
        }

        // mean pair {mean, margin}, margin is the half-width of the confidence interval
        auto& mean_pair() const {
            return mean_pair_;
        }

        // stddev pair {stddev, margin}, margin is assymetric
        auto& stddev_pair() const {
            return stddev_pair_;
        }

    private:
        std::pair<double, double> mean_pair_;
        std::pair<double, double> stddev_pair_;

        static auto calc_mean_margin(double stddev, double confidence, int size) {
            return t_critical(confidence, size - 1) * stddev / std::sqrt(size); // margin of error for the mean
        }

        static auto calc_stddev_margin(double stddev, double confidence, int size) {
            auto df = size - 1;
            auto alpha = 1.0 - confidence; // e.g., 0.05 for 95%

            // Use inverse chi-squared for large df
            auto chi2_lower = chi2_critical(alpha / 2, df);       // chi2.ppf(1 - alpha/2)
            auto chi2_upper = chi2_critical(1.0 - alpha / 2, df); // chi2.ppf(alpha/2)

            auto lower_bound = std::sqrt(df * stddev * stddev / chi2_upper);
            auto upper_bound = std::sqrt(df * stddev * stddev / chi2_lower);

            return upper_bound - lower_bound;
        }

        // t-critical value using bisection
        static double t_critical(double conf, int df) {
            auto alpha = 1.0 - conf;
            auto target = 1.0 - alpha / 2.0;
            auto low = 0.0, high = 10.0;

            while ((high - low) > 1e-10) {
                auto mid = (low + high) / 2.0;
                if (t_cdf(mid, df) < target) low = mid;
                else high = mid;
            }

            return (low + high) / 2.0;
        }

        static double t_cdf(double t, int df) {
            auto x = df / (df + t * t);
            return t < 0 ? incomplete_beta(df / 2.0, 0.5, x) / 2.0
                : 1.0 - incomplete_beta(df / 2.0, 0.5, x) / 2.0;
        }

        static double chi2_critical(double p, int df) {
            auto low = 0.0, high = 1000.0;
            
            while ((high - low) > 1e-8) {
                auto mid = (low + high) / 2.0;
                if (chi2_cdf(mid, df) < p) low = mid;
                else high = mid;
            }
            
            return (low + high) / 2.0;
        }

        static double chi2_cdf(double x, int df) {
            return incomplete_gamma(df / 2.0, x / 2.0);
        }

        // Incomplete beta function (adapted from Lentz's algorithm)
        static double incomplete_beta(double a, double b, double x) {
            if (x <= 0.0) return 0.0;
            if (x >= 1.0) return 1.0;

            constexpr auto max_iter = 100;
            constexpr auto epsilon = 1e-10, fp_min = 1e-30;

            auto qab = a + b;
            auto qap = a + 1.0;
            auto qam = a - 1.0;
            auto c = 1.0, d = 1.0 - qab * x / qap;
            if (std::fabs(d) < fp_min) d = fp_min;
            d = 1.0 / d;
            auto h = d;

            for (auto m = 1, m2 = 2; m <= max_iter; ++m, m2 += 2) {
                auto aa = m * (b - m) * x / ((qam + m2) * (a + m2));
                d = 1.0 + aa * d;
                if (std::fabs(d) < fp_min) d = fp_min;
                c = 1.0 + aa / c;
                if (std::fabs(c) < fp_min) c = fp_min;
                d = 1.0 / d;
                h *= d * c;

                aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
                d = 1.0 + aa * d;
                if (std::fabs(d) < fp_min) d = fp_min;
                c = 1.0 + aa / c;
                if (std::fabs(c) < fp_min) c = fp_min;
                d = 1.0 / d;
                auto del = d * c;
                h *= del;

                if (std::fabs(del - 1.0) < epsilon) break;
            }

            auto bt = std::exp(std::lgamma(a + b) - std::lgamma(a) - std::lgamma(b)
                + a * std::log(x) + b * std::log(1.0 - x));
            return bt * h / a;
        }

        // Incomplete gamma function using series
        static double incomplete_gamma(double a, double x) {
            if (x < 0 || a <= 0) return 0.0;
            if (x == 0) return 0.0;
            if (constexpr auto max_iter = 100; x < a + 1.0) {
                // Series representation
                constexpr auto epsilon = 1e-10;
                auto ap = a;
                auto sum = 1.0 / a;
                auto del = sum;
                for (auto n = 1; n <= max_iter; ++n) {
                    ++ap;
                    del *= x / ap;
                    sum += del;
                    if (std::fabs(del) < std::fabs(sum) * epsilon) break;
                }
                return sum * std::exp(-x + a * std::log(x) - std::lgamma(a));
            }
            else {
                // Continued fraction (Lentz’s algorithm)
                constexpr auto epsilon = 1e-10, fp_min = 1e-30;
                auto b = x + 1.0 - a;
                auto c = 1.0 / fp_min;
                auto d = 1.0 / b;
                auto h = d;

                for (auto i = 1; i <= max_iter; ++i) {
                    auto an = -i * (i - a);
                    b += 2.0;
                    d = an * d + b;
                    if (std::fabs(d) < fp_min) d = fp_min;
                    c = b + an / c;
                    if (std::fabs(c) < fp_min) c = fp_min;
                    d = 1.0 / d;
                    auto delta = d * c;
                    h *= delta;
                    if (std::fabs(delta - 1.0) < epsilon) break;
                }

                return 1.0 - h * std::exp(-x + a * std::log(x) - std::lgamma(a));
            }
        }
    };
}
