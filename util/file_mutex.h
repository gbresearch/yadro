//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2022, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#pragma once

#include <thread>
#include <chrono>
#include <concepts>
#include <string>
#include "gberror.h"
#include "string_util.h"
#include "gbwin.h"

#ifdef POSIX
namespace gb::yadro::util
{
    //-------------------------------------------------------------------------
    // spin and wait class
    //-------------------------------------------------------------------------
    struct spin_wait
    {
        void yield()
        {
            if (spin_count < (nop_pause_limit >> 2)) { /*nop*/ }
            // Intel pause: https://tinyurl.com/yb3lh2ph
            else if (spin_count < nop_pause_limit) { __asm__ __volatile__("rep; nop" : : : "memory"); }
            else { std::this_thread::yield(); }
            ++spin_count;
        }

    private:
        unsigned long long spin_count{ num_cores > 1u ? 0u : nop_pause_limit };
        static constexpr unsigned nop_pause_limit = 32u;
        static inline const auto num_cores = std::thread::hardware_concurrency();
    };

    //-------------------------------------------------------------------------
    // global mutex for threads and processes
    //-------------------------------------------------------------------------
    struct global_mutex
    {
        // constructors
        global_mutex() = default;

        global_mutex(const char* file_name);

        global_mutex(const global_mutex& other) = delete;

        ~global_mutex();

        // lock operations
        void lock();

        bool try_lock();

        void unlock();

        // timed lock operations
        template< class Rep, class Period >
        bool try_lock_for(const std::chrono::duration<Rep, Period>& timeout_duration)
        {
            return try_lock_until(std::chrono::high_resolution_clock::now() + timeout_duration);
        }

        template< class Clock, class Duration >
        bool try_lock_until(const std::chrono::time_point<Clock, Duration>& timeout_time)
        {
            spin_wait spinner;
            while (std::chrono::high_resolution_clock::now() < timeout_time)
            {
                if (try_lock())
                    return true;
                spinner.yield();
            }
            return false;
        }

        // for shared mutex
        void lock_shared();

        bool try_lock_shared();

        void unlock_shared();

        template< class Rep, class Period >
        bool try_lock_shared_for(const std::chrono::duration<Rep, Period>& timeout_duration)
        {
            return try_lock_shared_until(std::chrono::high_resolution_clock::now() + timeout_duration);
        }

        template< class Clock, class Duration >
        bool try_lock_shared_until(const std::chrono::time_point<Clock, Duration>& timeout_time)
        {
            spin_wait spinner;
            while (std::chrono::high_resolution_clock::now() < timeout_time)
            {
                if (try_lock_shared())
                    return true;
                spinner.yield();
            }
            return false;
        }

        // writing additional binary data in the lock file
        template<class T>
        void write(const T& t) const
        {
            static_assert(std::is_trivial_v<T>);
            if (_handle != invalid_handle)
            {
                auto err = ::lseek(_handle, 0, SEEK_SET);
                gbassert(err != -1);
                err = ::write(_handle, static_cast<const void*>(std::addressof(t)), sizeof(T));
                gbassert(err != -1);
            }
            else
                gbassert(!"write failed: invalid handle");
        }

        template<class T>
        T read() const
        {
            static_assert(std::is_trivial_v<T>);
            T result;
            gbassert(_handle != invalid_handle);
            auto err = ::lseek(_handle, 0, SEEK_SET);
            gbassert(err != -1);
            err = ::read(_handle, static_cast<void*>(std::addressof(result)), sizeof(T));
            gbassert(err != -1);

            return result;
        }

        bool is_empty() const
        {
            auto size = ::lseek(_handle, 0, SEEK_END);
            gbassert(size != -1);
            return size == 0;
        }

    private:
        using file_handle_t = int;
        static constexpr file_handle_t invalid_handle = -1;
        file_handle_t _handle = invalid_handle;
        unsigned long long unique_tid = syscall(SYS_gettid);
    };

}
#endif

#ifdef GBWINDOWS
namespace gb::yadro::util
{
    struct global_mutex 
    {
        explicit global_mutex(const std::string& name)
            : h_mutex
            { CreateMutexA(
                nullptr,           // Default security attributes
                false,          // Initially not owned
                name.c_str())    // Name of the mutex
            },
            _name(name)
        {
            if (!h_mutex)
                throw_error(to_string("Failed to create mutex: ", _name, ", error: ", GetLastError()));
        }

        explicit global_mutex(const std::wstring& name)
            : h_mutex
            { CreateMutexW(
                nullptr,           // Default security attributes
                false,          // Initially not owned
                name.c_str())    // Name of the mutex
            },
            _name(from_wstring(name))
        {
            if (!h_mutex)
                throw_error(to_string("Failed to create mutex: ", _name, ", error: ", GetLastError()));
        }

        // Destructor that closes the mutex handle
        ~global_mutex() 
        {
            if (h_mutex) 
                CloseHandle(h_mutex);
        }

        // Lock the mutex, blocking until it is available
        void lock() 
        {
            if (WaitForSingleObject(h_mutex, INFINITE) != WAIT_OBJECT_0)
                throw_error(to_string("Failed to lock mutex: ", _name, ", error: ", GetLastError()));
        }

        // Unlock the mutex
        void unlock() 
        {
            if (!ReleaseMutex(h_mutex))
                throw_error(to_string("Failed to unlock mutex: ", _name, ", error: ", GetLastError()));
        }

        // Try to lock the mutex, returning immediately
        bool try_lock() 
        {
            return WaitForSingleObject(h_mutex, 0) == WAIT_OBJECT_0;
        }

        // Deleted copy constructor and assignment operator to prevent copying
        global_mutex(const global_mutex&) = delete;
        global_mutex& operator=(const global_mutex&) = delete;

    private:
        HANDLE h_mutex; // Handle to the mutex
        std::string _name;
    };
}
#endif
