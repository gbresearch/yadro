//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2023, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#pragma once
#include <thread>
#include <mutex>
#include <string>
#include <chrono>
#include <sstream>
#include <functional>
#include <memory>
#include <ostream>
#include <fstream>
#include <concepts>
#include <process.h> // for getpid
#include <cassert>
#include <map>
#include <set>
#include <iostream>

// log utilities
namespace gb::yadro::util
{
    //-----------------------------------------------------------------
    // write in tab positions filling blanks with spaces
    struct tab
    {
        std::streampos position;
        char fill_char = ' ';

        friend auto& operator<< (std::ostream& os, const tab& p)
        {
            auto pos = os.tellp();
            assert(pos != -1);
            if (pos < p.position)
                os << std::string(static_cast<std::size_t>(p.position - pos), p.fill_char);
            else
                os << p.fill_char;
            return os;
        }
    };

    namespace literals
    {
        consteval auto operator""_log(unsigned long long id);
    }

    template<class T>
    concept c_binder = requires { {std::declval<T>().id}->std::convertible_to<int>; std::declval<T>() >> std::cout; };
    template<class T>
    concept c_not_binder = !c_binder<T>;
    //-----------------------------------------------------------------
    // thread-safe logger
    // 
    // example:
    // 
    // logger log(0_log >> std::cout >> "file.txt" >> std::err, 1_log >> "debug.log");
    // log.writeln(a,b,c,pad_to(n),...); // writes to 0_log, i.e. std::cout, file "file.txt", and std::err
    // log.writeln(1_log, "debug stream"); // writes to 1_log, i.e. file "debug.log"
    // log(1_log) << "debug stream"; // same as above
    // log.add_streams(1_log >> "another.file"); // add file stream "another.file" to 1_log
    // log.add_stream("another_file.log"); // add file stream "another.file" to 0_log
    //
    // another example, create a log hierarchy:
    // inline const auto debug_log = 2_log >> "program-debug.log" >> logger::verbose_tag{}; // debug logs go to only "program-debug.log" file, set verbose true
    // inline const auto info_log = 1_log >> "program-info.log" >> debug_log; // info logs go to "program-info.log" and debug logs
    // inline const auto default_log = 0_log >> std::cout >> "program.log" >> info_log; // default logs go to all streams
    // logger log1(default_log, debug_log, info_log); // enable all logs
    // write to specific logs
    // log.writeln(default_log, "default log");
    // log.writeln(info_log, "info log");
    // log.writeln(debug_log, "debug log #", 5);
    // log(debug_log) << "debug log #5"; // same as above
    // log(0_log, 1_log) << "message goes to 0_log and 1_log";
    //-----------------------------------------------------------------

    struct logger
    {
        friend consteval auto literals::operator""_log(unsigned long long id);
        struct verbose_tag {};

        logger() = default;

        logger(auto&& ...binders_or_streams) try
            // can't move outside, because of VC++ bug
            // error C2600: cannot define a compiler-generated special member function (must be declared in the class first)
            // https://developercommunity.visualstudio.com/t/C-compiler-bug:-error-C2600:-logger::/10509123
        {
            add_streams(std::forward<decltype(binders_or_streams)>(binders_or_streams)...);
        }
        catch (std::exception& e)
        {
            std::cerr << "failed to initialize logger: " << e.what() << std::endl;
        }
        catch (...)
        {
            std::cerr << "failed to initialize logger: unknown error" << std::endl;
        }

        auto operator() (c_binder auto&& ...binders) const { return log_proxy(*this, std::forward<decltype(binders)>(binders)...); }
        auto operator() () const; // using default binder

        auto& write(c_binder auto&& binder, auto&& ... msg) const;
        auto& write(c_not_binder auto&& ... msgs) const; // using default binder
        auto& writeln(auto&& ... params) const;

        auto& add_streams(c_binder auto&& ... binders);
        auto& add_streams(c_not_binder auto&& ... streams); // using default binder

        void flush();

        void set_verbose(bool v) { _verbose = v; }
        bool get_verbose() const { return _verbose; }

    private:
        bool _verbose{ false };
        std::map<std::string, std::unique_ptr<std::ofstream>> _name_map; // {file_name, stream}
        std::multimap<int, std::ostream*> _log_map; // { category, stream }
        mutable std::mutex _m;

        template<class ...T>
        struct stream_binder
        {
            const int id;
            std::tuple<T...> streams;
            bool verbose = false;

            auto operator>> (verbose_tag) const
            {
                return stream_binder<T...>{id, streams, true};
            }
            template<class char_t>
            auto operator>> (const char_t* name) const
            {
                return stream_binder<T..., const char_t*>{id, std::tuple_cat(streams, std::tuple(name))};
            }
            template<class char_t, class traits_t, class alloc_t>
            auto operator>> (const std::basic_string< char_t, traits_t, alloc_t>& name) const
            {
                return stream_binder<T..., std::basic_string< char_t, traits_t, alloc_t>>{id, std::tuple_cat(streams, std::tuple(name))};
            }
            template<class char_t, class traits_t>
            auto operator>> (std::basic_ostream<char_t, traits_t>& os) const
            {
                return stream_binder<T..., std::basic_ostream<char_t, traits_t>*>{id, std::tuple_cat(streams, std::tuple(&os))};
            }
            template<class ...U>
            auto operator>> (const stream_binder<U...>& other) const
            {
                return stream_binder<T..., U...>{id, std::tuple_cat(streams, other.streams)};
            }
        };
        
        template<class ...Binder>
        struct log_proxy 
        {
            log_proxy(const logger& log, const Binder& ...binders) : log(log), binders(binders...) {}
            ~log_proxy() { std::apply([this](auto&& binder) { log.write(binder, oss.str()); }, binders); }
            log_proxy& operator<< (auto&& v) { oss << std::forward<decltype(v)>(v); return *this; }
            log_proxy& operator<< (std::ios_base& (*func)(std::ios_base&)) { func(oss); return *this; }
            log_proxy& operator<< (std::basic_ios<char, std::char_traits<char>>& (*func)(std::basic_ios<char, std::char_traits<char>>&)) { func(oss); return *this; }
            log_proxy& operator<< (std::basic_ostream<char, std::char_traits<char>>& (*func)(std::basic_ostream<char, std::char_traits<char>>&)) { func(oss); return *this; }

        private:
            const logger& log;
            std::tuple<Binder...> binders;
            std::ostringstream oss;
        };

        template<class...T>
        auto add_stream_binder(const stream_binder<T...>& binder)
        {
            std::apply([&](auto&& ... streams) 
                {
                    (add_stream(binder.id, streams), ...);
                }, binder.streams);
        }

        auto add_stream(int cat, const std::string& file_name)
        {
            if (auto it = _name_map.find(file_name); it != _name_map.end())
            {
                _log_map.insert({ cat, it->second.get() });
            }
            else
            {
                auto ofs = std::make_unique<std::ofstream>(file_name);
                if (!*ofs)
                    throw std::runtime_error("failed to open log file: " + file_name);

                _log_map.insert({ cat, ofs.get() });
                _name_map[file_name] = std::move(ofs);
            }
        }

        auto add_stream(int cat, std::ostream* os)
        {
            _log_map.insert({ cat, os });
        }
    };

    inline auto& logger::write(c_binder auto&& binder, auto&& ... msg) const
    {
        std::lock_guard _(_m);
        std::set<std::ostream*> outputs;

        for (auto [beg, end] = _log_map.equal_range(binder.id); beg != end; ++beg)
        {
            auto output = beg->second;
            if (!outputs.contains(output)) // logs may countain the same streams, avoid repeating
            {
                outputs.insert(output);
                if (_verbose || binder.verbose)
                {
                    auto time_stamp{ std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()) };
                    (*output) << "[" << std::put_time(std::localtime(&time_stamp), "%F %T") << "] [pid: " << ::getpid()
                        << ", tid: " << std::this_thread::get_id() << "]\t";
                }
                ((*output) << ... << std::forward<decltype(msg)>(msg));
            }
        }
        return *this;
    }

    inline auto& logger::write(c_not_binder auto&& ... msgs) const
    {
        return write(stream_binder<>{0}, msgs...);
    }

    inline auto& logger::writeln(auto&& ... params) const
    {
        return write(std::forward<decltype(params)>(params), "\n");
    }

    inline auto& logger::add_streams(c_binder auto&& ... binders)
    {
        std::lock_guard _(_m);
        (add_stream_binder(binders), ...);
        return *this;
    }

    inline auto& logger::add_streams(c_not_binder auto&& ... streams)
    {
        return add_streams((stream_binder<>{0} >> std::forward<decltype(streams)>(streams)) ...);
    }

    inline void logger::flush()
    {
        for (auto&& stream : _name_map)
            stream.second->flush();
        for (auto&& stream : _log_map)
            stream.second->flush();
    }

    inline consteval auto literals::operator""_log(unsigned long long id) { return logger::stream_binder<>{ (int)id }; }

    inline auto logger::operator() () const { using namespace literals;  return log_proxy(*this, 0_log); }
}
