//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2022, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#pragma once

#include <array>
#include <algorithm>
#include <memory>
#include <cstddef>
#include <iterator>
#include <span>
#include <ranges>
#include <cstdint>
#include "../util/gberror.h"
#include "../util/misc.h"
#include "../util/string_util.h"

namespace gb::yadro::container
{
    //----------------------------------------------------------------------------------------------
    // requires default-initializable types
    template<class T, auto N>
    struct static_vector
    {
        //----------------------------
        // typedefs
        //----------------------------
        using value_type = T;
        using size_type = decltype(N);
        using difference_type = std::ptrdiff_t;
        using reference = value_type&;
        using const_reference = const value_type&;
        using pointer = value_type*;
        using const_pointer = const value_type*;
        using iterator = typename std::array<T, N>::iterator;
        using const_iterator = typename std::array<T, N>::const_iterator;
        using reverse_iterator = typename std::array<T, N>::reverse_iterator;
        using const_reverse_iterator = typename std::array<T, N>::const_reverse_iterator;

        //----------------------------------------------------------------------------------------------
        template<class Archive>
        void serialize(Archive&& a)
        {
            a(_size);
            a(std::span(begin(), end()));
        }

        //----------------------------------------------------------------------------------------------
        static_vector() = default;

        //----------------------------------------------------------------------------------------------
        constexpr explicit static_vector(size_type count, const T& value = T())
            : _size(count)
        {
            util::gbassert(count <= N);
            std::ranges::uninitialized_fill_n(_buffer.begin(), _size, value);
        }

        //----------------------------------------------------------------------------------------------
        template<std::forward_iterator It1, std::sentinel_for<It1> It2>
        constexpr static_vector(It1 first, It2 last)  requires(std::equality_comparable_with<It1, It2>)
        {
            auto [from_it, to_it] = std::ranges::uninitialized_copy(first, last, _buffer.begin(), _buffer.end());
            _size = static_cast<size_type>(std::distance(_buffer.begin(), to_it));
            util::gbassert(from_it == last); // whole input range copied
        }

        //----------------------------------------------------------------------------------------------
        template<class T1, size_type N1>
        constexpr explicit static_vector(const static_vector<T1, N1>& p) : static_vector(p.begin(), p.end())
        {
        }

        //----------------------------------------------------------------------------------------------
        template<class T1, size_type N1>
        static_vector& operator = (const static_vector<T1, N1>& p)
        {
            assign(p.begin(), p.end());
            return *this;
        }
        //----------------------------------------------------------------------------------------------
        constexpr iterator begin() { return _buffer.begin(); }
        //----------------------------------------------------------------------------------------------
        constexpr const_iterator begin() const { return _buffer.begin(); }
        //----------------------------------------------------------------------------------------------
        constexpr iterator end() { return _buffer.begin() + _size; }
        //----------------------------------------------------------------------------------------------
        constexpr const_iterator end() const { return _buffer.begin() + _size; }
        //----------------------------------------------------------------------------------------------
        constexpr reference operator[](size_type n)
        {
            assert(n < _size);
            return _buffer[n];
        }
        //----------------------------------------------------------------------------------------------
        constexpr const_reference operator[](size_type n) const
        {
            assert(n < _size);
            return _buffer[n];
        }
        //----------------------------------------------------------------------------------------------
        constexpr reference at(size_type n)
        {
            return _buffer.at(n);
        }
        //----------------------------------------------------------------------------------------------
        constexpr const_reference at(size_type n) const
        {
            return _buffer.at(n);
        }
        //----------------------------------------------------------------------------------------------
        constexpr size_type size() const { return _size; }
        //----------------------------------------------------------------------------------------------
        constexpr void swap(static_vector& p)
        {
            _buffer.swap(p._buffer);
            std::swap(_size, p._size);
        }
        //----------------------------------------------------------------------------------------------
        template<class U>
        constexpr void assign(size_type count, const U& value)
        {
            util::gbassert(count <= N);
            size_type i = 0;
            for (; i < count && i < _size; ++i)
                _buffer[i] = value;
            while (i < _size)
                pop_back();
            for (; i < count; ++i)
                push_back(value);
        }
        //----------------------------------------------------------------------------------------------
        template<std::forward_iterator Iterator, std::sentinel_for<Iterator> S>
        constexpr void assign(Iterator first, S last)
        {
            size_type count = 0;
            for (; first != last && count < _size; ++count, ++first)
                _buffer[count] = *first;
            while (count < _size)
                pop_back();
            for (; first != last; ++first)
                push_back(*first);
        }
        //----------------------------------------------------------------------------------------------
        constexpr reference back() { return _buffer[_size - 1]; }
        //----------------------------------------------------------------------------------------------
        constexpr const_reference back() const { return _buffer[_size - 1]; }
        //----------------------------------------------------------------------------------------------
        constexpr reference front() { return _buffer[0]; }
        //----------------------------------------------------------------------------------------------
        constexpr const_reference front() const { return _buffer[0]; }
        //----------------------------------------------------------------------------------------------
        template<class U>
        constexpr void push_back(U&& value)
        {
            util::gbassert(!full());
            std::construct_at(std::addressof(_buffer[_size]), std::forward<U>(value));
            ++_size;
        }
        //----------------------------------------------------------------------------------------------
        template<class ...U>
        constexpr void emplace_back(U&&... value)
        {
            util::gbassert(_size < N);
            std::construct_at(std::addressof(_buffer[_size]), std::forward<U>(value)...);
            ++_size;
        }
        //----------------------------------------------------------------------------------------------
        constexpr void pop_back()
        {
            util::gbassert(_size > 0);
            std::destroy_at(std::addressof(back()));
            --_size;
        }
        //----------------------------------------------------------------------------------------------
        template<class U>
        constexpr iterator insert(iterator position, U&& value)
        {
            push_back(std::forward<U>(value));
            for (auto i = end() - 1; i != position; --i)
                std::swap(*i, *(i - 1));
            return position;
        }
        //----------------------------------------------------------------------------------------------
        constexpr iterator insert(iterator position, size_type count, const T& value)
        {
            static_vector<T, N> tmp(begin(), position);
            for (; count; --count)
                tmp.push_back(value);
            for (auto i = position; i != end(); ++i)
                tmp.push_back(*i);

            *this = std::move(tmp);
            return position;
        }
        //----------------------------------------------------------------------------------------------
        template<std::forward_iterator It, std::sentinel_for<It> S>
        constexpr auto insert(iterator position, It first, S last)
        {
            static_vector<T, N> tmp(begin(), position);
            for (; first != last; ++first)
                tmp.push_back(*first);
            for (auto i = position; i != end(); ++i)
                tmp.push_back(*i);

            *this = std::move(tmp);
            return position;
        }
        //----------------------------------------------------------------------------------------------
        constexpr void clear() { while (!empty()) pop_back(); }
        //----------------------------------------------------------------------------------------------
        constexpr size_type capacity() const { return N; }
        //----------------------------------------------------------------------------------------------
        constexpr bool empty() const { return _size == 0; }
        //----------------------------------------------------------------------------------------------
        constexpr bool full() const { return _size == N; }
        //----------------------------------------------------------------------------------------------
        constexpr iterator erase(iterator position)
        {
            util::gbassert(_size > 0);
            std::move(position + 1, end(), position);
            pop_back();
            return position;
        }
        //----------------------------------------------------------------------------------------------
        constexpr iterator erase(iterator first, iterator last)
        {
            util::gbassert(_size > 0);
            std::move(last, end(), first);
            for (auto i = first; i != last; ++i)
                pop_back();
            return first;
        }
        //----------------------------------------------------------------------------------------------
        constexpr void resize(size_type size, const T& value = T())
        {
            util::gbassert(size <= N);
            while (size < _size)
                pop_back();
            while (size > _size)
                push_back(value);
        }
    private:
        size_type _size = 0;
        [[no_unique_address]] std::array<T, N> _buffer;

        //----------------------------------------------------------------------------------------------
        template<class Other>
        friend constexpr auto operator<=> (const static_vector& v1, const Other& v2) requires(std::three_way_comparable_with<T, typename Other::value_type>)
            && requires(const Other& v)
        {
            v.begin();
            v.size();
        }
        {
            return util::compare(std::span(v1.begin(), v1.size()), std::span(v2.begin(), v2.size()));
        }

        //----------------------------------------------------------------------------------------------
        template<class Other>
        friend constexpr auto operator== (const static_vector& v1, const Other& v2) { return std::is_eq(v1 <=> v2); }

        //----------------------------------------------------------------------------------------------
        template<class Other>
        friend constexpr auto operator!= (const static_vector& v1, const Other& v2) { return std::is_neq(v1 <=> v2); }
    };
} // namespaces
