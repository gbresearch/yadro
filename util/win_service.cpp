//-----------------------------------------------------------------------------
//  Copyright (C) 2024, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#include "win_service.h"

#ifdef GBWINDOWS
#include <strsafe.h>

// Microsoft example: https://learn.microsoft.com/en-us/windows/win32/services/svc-cpp

#pragma comment(lib, "advapi32.lib")

namespace gb::yadro::util//::winservice
{
    static SERVICE_STATUS service_status{};
    static SERVICE_STATUS_HANDLE service_status_handle{};
    static std::string service_name{};
    static main_fn_t main_fn{};
    static cleanup_fn_t cleanup_fn{};

    //-----------------------------------------------------------------------------
    static void WINAPI service_ctrl_handler(DWORD CtrlCode)
    {
        switch (CtrlCode) 
        {
        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            service_status.dwCurrentState = SERVICE_STOP_PENDING;
            SetServiceStatus(service_status_handle, &service_status);
            if (cleanup_fn) cleanup_fn();
            service_status.dwCurrentState = SERVICE_STOPPED;
            SetServiceStatus(service_status_handle, &service_status);
            break;
        default:
            break;
        }
    }

    //-----------------------------------------------------------------------------
    static void WINAPI service_main_entry(DWORD argc, LPTSTR* argv)
    {
        service_status_handle = RegisterServiceCtrlHandler(service_name.c_str(), service_ctrl_handler);

        if (!service_status_handle) {
            throw exception_t(to_string("RegisterServiceCtrlHandler failed with error: ", GetLastError()));
        }

        service_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
        service_status.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
        service_status.dwCurrentState = SERVICE_START_PENDING;
        SetServiceStatus(service_status_handle, &service_status);

        // Update the service status to running
        service_status.dwCurrentState = SERVICE_RUNNING;
        SetServiceStatus(service_status_handle, &service_status);

        // Wait indefinitely
        while (service_status.dwCurrentState == SERVICE_RUNNING) {
            Sleep(1000);
            main_fn(argc, const_cast<const char**>(argv));
        }

        // Service cleanup code here...

        service_status.dwCurrentState = SERVICE_STOPPED;
        SetServiceStatus(service_status_handle, &service_status);
    }

    //-----------------------------------------------------------------------------
    bool is_service()
    {
        auto is_srvc = false;

        if (auto hwin_station = GetProcessWindowStation(); hwin_station != NULL)
            if (USEROBJECTFLAGS uof; GetUserObjectInformation(hwin_station, UOI_FLAGS, &uof, sizeof(uof), NULL))
                is_srvc = (uof.dwFlags & WSF_VISIBLE) == 0;
        return is_srvc;
    }

    //-----------------------------------------------------------------------------
    int win_service_main(const char* name, main_fn_t main_function, cleanup_fn_t cleanup_function, int argc, const char* argv[])
    {
        service_name = name;
        main_fn = main_function;
        cleanup_fn = cleanup_function;

        if (is_service())
        {
            SERVICE_TABLE_ENTRY service_table[] = {
                {service_name.data(), (LPSERVICE_MAIN_FUNCTION)service_main_entry},
                {NULL, NULL}
            };

            if (!StartServiceCtrlDispatcher(service_table)) {
                throw util::exception_t(util::to_string("StartServiceCtrlDispatcher failed with error: ", GetLastError()));
            }
        }
        else
        {
            // Run as a standalone application
            main_fn(argc, argv);
        }

        return 0;
    }

    //-----------------------------------------------------------------------------
    void win_service_install(const char* service_name)
    {
        SC_HANDLE schSCManager;
        SC_HANDLE schService;
        TCHAR szUnquotedPath[MAX_PATH];

        if (!GetModuleFileName(NULL, szUnquotedPath, MAX_PATH))
        {
            printf("Cannot install service (%d)\n", GetLastError());
            return;
        }

        // In case the path contains a space, it must be quoted so that
        // it is correctly interpreted. For example,
        // "d:\my share\myservice.exe" should be specified as
        // ""d:\my share\myservice.exe"".
        TCHAR szPath[MAX_PATH];
        StringCbPrintf(szPath, MAX_PATH, TEXT("\"%s\""), szUnquotedPath);

        // Get a handle to the SCM database. 

        schSCManager = OpenSCManager(
            NULL,                    // local computer
            NULL,                    // ServicesActive database 
            SC_MANAGER_ALL_ACCESS);  // full access rights 

        if (NULL == schSCManager)
            throw util::exception_t(util::to_string("OpenSCManager error: ", GetLastError()));

        // Create the service

        schService = CreateService(
            schSCManager,              // SCM database 
            service_name,                   // name of service 
            service_name,                   // service name to display 
            SERVICE_ALL_ACCESS,        // desired access 
            SERVICE_WIN32_OWN_PROCESS, // service type 
            SERVICE_DEMAND_START,      // start type 
            SERVICE_ERROR_NORMAL,      // error control type 
            szPath,                    // path to service's binary 
            NULL,                      // no load ordering group 
            NULL,                      // no tag identifier 
            NULL,                      // no dependencies 
            NULL,                      // LocalSystem account 
            NULL);                     // no password 

        if (schService == NULL)
        {
            auto error = GetLastError();
            CloseServiceHandle(schSCManager);
            throw util::exception_t(util::to_string("CreateService error: ", error));
        }

        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);
    }

}
#endif
