//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2024, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#pragma once

#include <array>
#include <cassert>
#include <ranges>
#include <vector>
#include <concepts>
#include <tuple>
#include <algorithm>
#include <numeric>
#include <initializer_list>

namespace gb::yadro::container
{
    //---------------------------------------------------------------------------------------------
    // indexers
    //---------------------------------------------------------------------------------------------

    template<std::size_t D, std::size_t ...Ds>
    struct static_indexer_t
    {
        constexpr auto operator()(auto i, auto ...ds) const
        {
            static_assert(sizeof...(Ds) == sizeof...(ds));
            assert(i < D);
            if constexpr (sizeof...(Ds) == 0)
                return i;
            else
                return i + D * static_indexer_t<Ds...>{}(ds...);
        }
        static constexpr auto size() { return (D*...*Ds); }
        static constexpr auto cardinality() { return sizeof ...(Ds) + 1; }
    };

    //---------------------------------------------------------------------------------------------
    struct dynamic_indexer_t
    {
        dynamic_indexer_t(std::convertible_to<std::size_t> auto&& ... indexes)
            : _indexes{ static_cast<std::size_t>(indexes)... }
        {
        }

        constexpr auto operator()(auto i, auto ...ds) const
        {
            assert(i < _indexes[0]);
            if constexpr (sizeof...(ds) == 0)
                return i;
            else
                return i + _indexes[0] * dynamic_indexer_t{}(ds...);
        }

        constexpr auto size() const
        {
            return std::accumulate(_indexes.begin(), _indexes.end(), std::size_t(1),
                [](auto a, auto b) { return a * b; });
        }

        constexpr auto cardinality() const { return _indexes.size(); }

    private:
        std::vector<std::size_t> _indexes;
    };

    //---------------------------------------------------------------------------------------------
    template<class T, std::ranges::range container_t, class indexer_t>
    struct basic_tensor
    {
        basic_tensor() = default;
        basic_tensor(std::convertible_to<indexer_t> auto&& indexer,
            std::convertible_to<T> auto&& ... args) : _indexer(std::forward<decltype(indexer)>(indexer)),
            _data{ std::forward<decltype(args)>(args)... }
        {
        }

        constexpr auto& operator()(this auto&& self, auto... indexes)
        {
            return std::forward<decltype(self)>(self)._data[self._indexer(indexes...)];
        }

    private:
        indexer_t _indexer;
        container_t _data;
    };

    //---------------------------------------------------------------------------------------------
    template<class T, std::size_t ...Ds>
    struct static_tensor : basic_tensor<T, std::array<T, (1*...*Ds)>, static_indexer_t<Ds... >>
    {
        using indexer_t = static_indexer_t<Ds... >;
        using base_t = basic_tensor<T, std::array<T, (1*...*Ds)>, indexer_t>;
        static_tensor() = default;
        static_tensor(auto&& ... args) :
            base_t(indexer_t{}, std::forward<decltype(args)>(args)...)
        {
            static_assert(indexer_t::size() == sizeof...(args));
        }
    };

    //---------------------------------------------------------------------------------------------
    template<class T>
    struct dynamic_tensor : basic_tensor<T, std::vector<T>, dynamic_indexer_t>
    {
        using indexer_t = dynamic_indexer_t;
        using base_t = basic_tensor<T, std::vector<T>, indexer_t>;

        dynamic_tensor() = default;

        dynamic_tensor(std::convertible_to<indexer_t> auto&& indexer) :
            base_t{ std::forward<decltype(indexer)>(indexer) }
        {
        }

        dynamic_tensor(std::convertible_to<std::size_t> auto ... dimensions) :
            base_t(indexer_t(dimensions ...))
        {
        }
    };
}
