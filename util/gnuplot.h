//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2023, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#pragma once

#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <stdexcept>
#include <format>
#include <cstdlib>
#include "gbwin.h"

//-------------------------------------------------------------------------------------------------
// C++ interface for gnuplot (Windows only)
//-------------------------------------------------------------------------------------------------

namespace gb::yadro::util
{
    // sequences acceptable for plotting
    template<class T>
    concept c_sequence = requires { std::begin(std::declval<T>()); std::end(std::declval<T>()); };

    // exception thrown when gnuplot fails
    struct gnuplot_exception : public std::runtime_error
    {
        gnuplot_exception(const std::string& msg) : std::runtime_error(msg) {}
    };

    // gnuplot class
    struct gnuplot
    {
        //---------------------------------------------------------------------------------------------
        // plot styles
        enum style
        {
            s_line = 0, s_point, s_linepoint, s_impulse, s_dot, s_step, s_fstep, s_histep, s_box, s_filledcurve,
            s_histogram, s_label, s_xerrorbar, s_xerrorline, s_errorbar, s_errorline, s_yerrorbar,
            s_boxerrorbar, s_xyerrorbar, s_xyerrorline, s_boxxyerrorbar, s_financebar, s_candlestick,
            s_vector, s_image, s_rgbimage, s_pm3d,
            // smooth
            s_unique = 100, s_frequency, s_cspline, s_acspline, s_bezier, s_sbezier
        };

        //---------------------------------------------------------------------------------------------
        // constructor accepts option string and gnuplot path
        // if gnuplot_exe_path is empty then the PATH variable is searched for gnuplot.exe
        gnuplot(const std::string& options = "-p", const std::string& gnuplot_exe_path = "");

        //---------------------------------------------------------------------------------------------
        ~gnuplot();

        //---------------------------------------------------------------------------------------------
        // send a command to gnuplot via opened pipe
        gnuplot& cmd(const std::string& cmdstr);

        //---------------------------------------------------------------------------------------------
        gnuplot& set_terminal_output() { return cmd("set output").cmd("set terminal windows"); }

        //---------------------------------------------------------------------------------------------
        // saves a gnuplot session to a postscript file
        gnuplot& set_postscript_output(const std::string& filename)
        {
            return cmd("set terminal postscript color").cmd(std::format("set output \"{}.ps\"", filename));
        }

        //---------------------------------------------------------------------------------------------
        // saves a gnuplot session to a png file
        gnuplot& set_png_output(const std::string& filename)
        {
            return cmd("set term png").cmd(std::format("set output \"{}.png\"", filename));
        }

        //---------------------------------------------------------------------------------------------
        // plots

        auto& plot(auto&& ... args)
        {
            return plot_imp("plot", std::forward<decltype(args)>(args)...);
        }
        auto& replot(auto&& ... args)
        {
            return plot_imp("replot", std::forward<decltype(args)>(args)...);
        }
        auto& splot(auto&& ... args)
        {
            return plot_imp("splot", std::forward<decltype(args)>(args)...);
        }

        //---------------------------------------------------------------------------------------------
        // reset gnuplot
        gnuplot& reset();

    private:
        // clean up at program exit
        struct cleaner_t
        {
            ~cleaner_t()
            {
                for (auto&& p : _tmpfiles)
                    std::filesystem::remove(p);
            }
            void add(const std::filesystem::path& p)
            {
                _tmpfiles.push_back(p);
            }
        private:
            std::vector<std::filesystem::path> _tmpfiles;
        };

        // data
        FILE* _exe_pipe{};
        static cleaner_t cleaner;

        // plot implementations for different parameters
        auto& plot_imp(const std::string& verb, const std::string& title, style style, c_sequence auto&& ... data)
        {
            auto posix_path = write_data_file([&](auto&& tmp)
                {
                    auto size = std::min({ std::distance(std::begin(data), std::end(data))... });

                    for (auto i = 0; i < size; ++i)
                    {
                        ((tmp << *(std::end(data) - size + i) << ' '), ...);
                        tmp << "\n";
                    }
                });

            auto cmd_str = std::format("{} \"{}\" using ", verb, posix_path);

            for (size_t i = 1; i <= sizeof...(data); ++i)
            {
                cmd_str += std::to_string(i);
                if (i != sizeof...(data))
                    cmd_str += ":";
            }

            if (title.empty())
                cmd_str += " notitle ";
            else
                cmd_str += " title \"" + title + "\" ";

            cmd_str += style_str(style);

            return cmd(cmd_str);
        }

        // plot bitmap image
        auto& plot_imp(const std::string& verb, const std::string& title, const unsigned char* ucPicBuf, unsigned iWidth, unsigned iHeight)
        {
            auto posix_path = write_data_file([=](auto&& tmp)
                {
                    for (auto iRow = 0u, iIndex = 0u; iRow < iHeight; iRow++)
                        for (auto iColumn = 0u; iColumn < iWidth; iColumn++)
                        {
                            tmp << iColumn << " " << iRow << " "
                                << static_cast<float>(ucPicBuf[iIndex++]) << std::endl;
                        }
                });

            auto cmd_str = title.empty() ?
                std::format("{} \"{}\" notitle with image", verb, posix_path)
                : std::format("{} \"{}\" title \"{}\" with image", verb, posix_path, title);

            return cmd(cmd_str);
        }

        // plot line ax + b
        auto& plot_imp(const std::string& verb, style s, double a, double b, const std::string& title = "")
        {
            return cmd(std::format("{} {} * x + {} title \"{}\" {}", verb,
                a, b, title.empty() ? std::format("{} * x + {}", a, b) : title, style_str(s)));
        }


        // binary operators: ** exponentiation, * multiply, / divide, + add, - substract, % modulo
        // unary operators: - minus, ! factorial
        // elementary functions: rand(x), abs(x), sgn(x), ceil(x), floor(x), int(x), imag(x), real(x), arg(x),
        //   sqrt(x), exp(x), log(x), log10(x), sin(x), cos(x), tan(x), asin(x), acos(x), atan(x), atan2(y,x),
        //   sinh(x), cosh(x), tanh(x), asinh(x), acosh(x), atanh(x)
        // special functions: erf(x), erfc(x), inverf(x), gamma(x), igamma(a,x), lgamma(x), ibeta(p,q,x),
        //   besj0(x), besj1(x), besy0(x), besy1(x), lambertw(x)
        // statistical fuctions: norm(x), invnorm(x)
        // 2D plots can use variable "x", 3D plots can use variables "x" and "y"
        gnuplot& plot_imp(const std::string& verb, style s, const std::string& equation, const std::string& title = "")
        {
            return cmd(std::format("{} {} title \"{}\" {}", verb, equation,
                title.empty() ? equation : title, style_str(s)));
        }

        static auto style_str(style s) -> std::string
        {
            static const std::map<unsigned, std::string> s_map
            {
                {s_line, "lines"},
                {s_point, "points"},
                {s_linepoint, "linespoints"},
                {s_impulse, "impulses"},
                {s_dot, "dots"},
                {s_step, "steps"},
                {s_fstep, "fsteps"},
                {s_histep, "histeps"},
                {s_box, "boxes"},
                {s_filledcurve, "filledcurves"},
                {s_histogram, "histograms"},
                {s_label, "labels"},                // 3 columns of data are required
                {s_xerrorbar, "xerrorbars"},        // 3-4 columns of data are required
                {s_xerrorline, "xerrorlines"},      // 3-4 columns of data are required
                {s_errorbar, "errorbars"},          // 3-4 columns of data are required
                {s_errorline, "errorlines"},        // 3-4 columns of data are required
                {s_yerrorbar, "yerrorbars"},        // 3-4 columns of data are required
                {s_boxerrorbar, "boxerrorbars"},    // 3-5 columns of data are required
                {s_xyerrorbar, "xyerrorbars"},      // 4,6,7 columns of data are required
                {s_xyerrorline, "xyerrorlines"},    // 4,6,7 columns of data are required
                {s_boxxyerrorbar, "boxxyerrorbars"},// 4,6,7 columns of data are required
                {s_financebar, "financebars"},      // 5 columns of data are required
                {s_candlestick, "candlesticks"},    // 5 columns of data are required
                {s_vector, "vectors"},
                {s_image, "image"},
                {s_rgbimage, "rgbimage"},
                {s_pm3d, "pm3d"},

                {s_unique, "unique"},
                {s_frequency, "frequency"},
                {s_cspline, "csplines"},
                {s_acspline, "acsplines"},
                {s_bezier, "bezier"},
                {s_sbezier, "sbezier"},
            };

            return (s < 100 ? "with " : "smooth ") + s_map.at(s);
        }

        //---------------------------------------------------------------------------------------------
        auto write_data_file(auto&& write_fn, auto&& ... args)
        {
            if (auto path = get_temp_file_path(".gnuplot"); !path.empty())
            {
                std::ofstream tmp(path);
                if (tmp)
                {
                    write_fn(tmp, std::forward<decltype(args)>(args)...);

                    cleaner.add(path);

                    auto posix_path{ path.string() };
                    std::replace(posix_path.begin(), posix_path.end(), '\\', '/'); // gnuplot expects posix path

                    return posix_path;
                }
                else
                    throw gnuplot_exception("Failed to create temp file: " + path.string());
            }
            else
                throw gnuplot_exception("Failed to obtain temp file path");
        }

    };

    inline gnuplot::~gnuplot()
    {
        _pclose(_exe_pipe);
    }

    //------------------------------------------------------------------------------
    //
    // resets a gnuplot session and sets all varibles to default
    //
    inline gnuplot& gnuplot::reset()
    {
        cmd("reset");
        cmd("clear");
        set_terminal_output();
        return *this;
    }

    //------------------------------------------------------------------------------
    //
    // Sends a command to an active gnuplot session
    //
    inline gnuplot& gnuplot::cmd(const std::string& cmdstr)
    {
#if defined(_DEBUG)
        std::cout << cmdstr << std::endl;
#endif

        fputs((cmdstr + "\n").c_str(), _exe_pipe);
        fflush(_exe_pipe);
        return *this;
    }

    //------------------------------------------------------------------------------
    //
    // Opens up a gnuplot session, ready to receive commands
    //
    inline gnuplot::gnuplot(const std::string& options, const std::string& gnuplot_exe_path)
    {
        if (std::filesystem::exists(gnuplot_exe_path))
        {
            if (_exe_pipe = _popen(('"' + gnuplot_exe_path + "\" " + options).c_str(), "w"); !_exe_pipe)
                throw gnuplot_exception("Failed to start: " + gnuplot_exe_path);
        }
        else
        {
            if (auto path = std::getenv("PATH"); path)
            {
                for (auto s : tokenize(std::string(path), ';'))
                    if (auto exe = s + "\\gnuplot.exe"; std::filesystem::exists(exe))
                    {
                        if (_exe_pipe = _popen(('"' + exe + "\" " + options).c_str(), "w"); !_exe_pipe)
                            throw gnuplot_exception("Failed to start: " + exe);

                        break;
                    }

                if (!_exe_pipe)
                    throw gnuplot_exception("Path doesn't contain gnuplot.exe");
            }
            else
            {
                throw gnuplot_exception("Path is not set");
            }
        }
        set_terminal_output();
    }

    inline gnuplot::cleaner_t gnuplot::cleaner; // static cleaner
}
