//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2022, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#pragma once

#include <atomic>
#include <chrono>
#include <functional>
#include <map>
#include <mutex>
#include <string>
#include <type_traits>

namespace gb::yadro::util
{
    //---------------------------------------------------------------------
    /**
    * Accumulating timer
    * 1. Create timer:
    *        static auto timer = make_accumulating_timer("timer name");
    *    or:
    *        static accumulating_timer timer(
    *          [](auto duration, auto count) {
    *            std::cout << "time: " << duration.count() << " ms, count: " << count << '\n';
    *          });
    * 2. Start/stop timer:
    *        {
    *          auto scoped_timer{ timer.make_scope_timer() };
    *          <some code>
    *        }
    *    or:
    *        auto scoped_timer{ timer.make_scope_timer() };
    *        <some code>
    *        scoped_timer.stop();
    */
    
    namespace detail
    {
        // nonlocking_mutex used in single threaded context
        struct nonlocking_mutex
        {
            void lock() const {}
            void unlock() const {}
        };
    }

    template<
        class time_unit,
        class clock = std::chrono::high_resolution_clock,
        class mutex = detail::nonlocking_mutex
    >
    struct accumulating_timer
    {

        template<class F>
        accumulating_timer(F fn)
            : _fn{ fn }
        {
        }

        auto& operator+= (auto d)
        {
            std::scoped_lock lock(_m);
            _duration += d;
            ++_count;
            return *this;
        }

        ~accumulating_timer() { report(); }

        void report() const
        {
            _fn(std::chrono::duration_cast<time_unit>(_duration), _count);
        }

        const auto& get_duration() const { return _duration; }
        const auto get_count() const { return _count; }

        auto make_scope_timer() { return scope_timer(this); }

    private:
        std::function<void(time_unit, std::size_t)> _fn;
        typename clock::duration _duration{};
        std::size_t _count{};
        mutex _m;

        struct scope_timer
        {
            scope_timer(accumulating_timer<time_unit, clock, mutex>* t) :
                _atimer{ t },
                _start{ clock::now() }
            {}

            scope_timer(scope_timer&& other) :
                _atimer(other._atimer),
                _start(std::move(other._start))
            {
                other._atimer = nullptr;
                other._start = {};
            }

            ~scope_timer()
            {
                stop();
            }

            void stop()
            {
                if (_atimer && _start != time_point{})
                    *_atimer += clock::now() - _start;
                _atimer = nullptr;
            }

            void pause()
            {
                if (_atimer && _start != time_point{})
                    *_atimer += clock::now() - _start;
                _start = {};
            }

            void start()
            {
                _start = clock::now();
            }

        private:
            accumulating_timer<time_unit, clock, mutex>* _atimer;
            using time_point = typename clock::time_point;
            time_point _start;
        };
    };

    template<class duration>
    constexpr auto get_duration_suffix()
    {
        return duration::period::num != 1 ? "some units"
            : duration::period::den == 1'000'000'000 ? "nanosec"
            : duration::period::den == 1'000'000 ? "microsec"
            : duration::period::den == 1'000 ? "millisec"
            : duration::period::den == 1 ? "sec"
            : "some units";
    }

    template<class time_unit,
        class clock = std::chrono::high_resolution_clock,
        class mutex = detail::nonlocking_mutex>
    inline [[nodiscard]] auto make_accumulating_timer(std::string name)
    {
        return accumulating_timer<time_unit, clock, mutex>([=](auto duration, auto count)
            {
                const auto& duration_s = std::to_string(duration.count()) + ' ' + get_duration_suffix<time_unit>();
                printf(":TIMER: %s time: %s, count: %zu\n", name.c_str(), duration_s.c_str(), count);
            });
    }

    // dependent timers for sub-blocks
    template<class time_unit, class clock, class mutex>
    inline [[nodiscard]] auto make_slave_timer(std::string name, const accumulating_timer<time_unit, clock, mutex>& master_timer)
    {
        return accumulating_timer<time_unit, clock, mutex>(
            [timer_name = std::move(name), master = &master_timer](auto duration, auto count)
        {
            auto duration_s = std::to_string(duration.count()) + ' ' + get_duration_suffix<time_unit>();

            if (master->get_duration().count()) {
                auto percentage = 100.0 * duration.count() / std::chrono::duration_cast<time_unit>(master->get_duration()).count();
                printf(":SLAVE TIMER: %s time: %s (%f %%), count: %zu\n",
                    timer_name.c_str(), duration_s.c_str(), percentage, count);
            }
            else {
                printf(":SLAVE TIMER: %s time: %s, count: %zu\n",
                    timer_name.c_str(), duration_s.c_str(), count);
            }
        });
    }


    // global_timer_map is used to create global timers
    // instantiate it in main(), so the reporting be done at exit from main(),
    // to prevent undefined behavior if the reporting_fn depends on other global variables
    template<class time_unit,
        class clock = std::chrono::high_resolution_clock,
        class mutex = std::mutex>
    struct global_timer_map_t
    {
        ~global_timer_map_t()
        {
            get_map().clear();
        }

        static auto& get_map()
        {
            static std::map<std::string,
                gb::yadro::util::accumulating_timer<time_unit, std::chrono::high_resolution_clock, std::mutex>>
                timer_map;
            return timer_map;
        }
        
        static auto& get(const std::string& name, auto reporting_fn)
        {
            return get_map().try_emplace(name, reporting_fn).first->second;
        }
    };
}
