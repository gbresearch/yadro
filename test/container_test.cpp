//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2024, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#include "../util/gbtest.h"
#include "../util/misc.h"
#include "../container/tensor.h"
#include "../container/matrix.h"
#include "../container/matrix_functions.h"
#include "../container/static_string.h"
#include "../container/static_vector.h"
#include "../container/tree.h"
#include "../archive/archive.h"
#include <vector>

namespace
{
    using namespace gb::yadro::container;
    using namespace gb::yadro::util;
    using namespace gb::yadro::archive;
    using namespace gb::yadro::matrix_operators;
    
    GB_TEST(yadro, static_string_test)
    {
        static_string<1> s1;
        gbassert(s1.size() == 0);
        const static_string<10> s2(5, 'a');
        gbassert(s2 != s1);
        static_string<11> s3("aaaaa");
        gbassert(s2 == s3);
        gbassert(s2 == "aaaaa");
        gbassert("aaaaa" == s2);
        gbassert("aaaaaB" != s2);
        gbassert("aaaaaB" > s2);
        gbassert(s2 < "aaaaaB");
        s3 += 'B';
        gbassert("aaaaaB" == s3);
        s3 += "BCD";
        gbassert(s3 == "aaaaaBBCD");
        s3 = "AbCdE";
        gbassert(s3 == "AbCdE");
        s3 += s2;
        gbassert(s3 == "AbCdEaaaaa");
        s3 = s2;
        s3 += "AbCdE";
        gbassert(s3 == "aaaaaAbCdE");
        std::fill_n(s3.begin(), 5, 'x');
        gbassert(s3 == "xxxxxAbCdE");
        s3.clear();
        gbassert(!s3);
        s3 = "12345";
        gbassert(s3 + s2 == "12345aaaaa");
        gbassert(s3 + "aaaaa" == "12345aaaaa");
        gbassert(s3 + 'X' == "12345X");
        gbassert(s3 + std::string("-x") == "12345-x");

        std::ostringstream oss;
        oss << s2;
        gbassert(oss.str() == "aaaaa");

        omem_archive<> ma;
        ma(s2, static_string<11>("123"));
        imem_archive im(std::move(ma));
        static_string<12> s4;
        im(s3, s4);
        gbassert(s2 == s3);
        gbassert(s4 == static_string<11>("123"));
    }

    GB_TEST(yadro, static_vector_test)
    {
        static_vector<int, 1> v1;
        gbassert(v1.empty());
        std::vector v{ 1,2,3,4,5 };
        static_vector<int, 10> v2(v.begin(), v.end());
        gbassert(std::mismatch(v2.begin(), v2.end(), v.begin(), v.end()) == std::pair(v2.end(), v.end()));
        gbassert(v1 < v2);
        gbassert(v2 == v);
        v2.clear();
        gbassert(v1 == v2);
        static_vector<int, 12> v3(4, 5);
        gbassert(v3 == std::vector{ 5, 5, 5, 5 });
        auto v4 = v3;
        gbassert(v3 == v4);
        v4[3] = 10;
        gbassert(v4 == std::vector{ 5,5,5,10 });
        v4.swap(v3);
        gbassert(v3 == std::vector{ 5, 5, 5, 10 });
        gbassert(v4 == std::vector{ 5, 5, 5, 5 });
        v4.assign(10, 7);
        gbassert(v4 == std::vector{ 7,7,7,7,7,7,7,7,7,7 });
        v4.assign(v.begin(), v.end());
        gbassert(v4 == v);
        v4.assign(3, 2);
        gbassert(v4 == std::vector{ 2,2,2 });
        v4.push_back(9);
        gbassert(v4 == std::vector{ 2,2,2,9 });
        v4.emplace_back(7);
        gbassert(v4 == std::vector{ 2,2,2,9,7 });
        v4.pop_back();
        gbassert(v4 == std::vector{ 2,2,2,9 });
        v4.insert(v4.begin() + 2, 111);
        gbassert(v4 == std::vector{ 2,2,111,2,9 });
        v4.insert(v4.begin() + 3, 3, 11);
        gbassert(v4 == std::vector{ 2,2,111,11,11,11,2,9 });
        v4.insert(v4.begin(), v.begin(), v.begin() + 3);
        gbassert(v4 == std::vector{ 1,2,3,2,2,111,11,11,11,2,9 });
        gbassert(v4.capacity() == 12);
        gbassert(!v4.empty());
        gbassert(!v4.full());
        v4.erase(v4.begin() + 2);
        gbassert(v4 == std::vector{ 1,2,2,2,111,11,11,11,2,9 });
        v4.erase(v4.begin() + 1, v4.begin() + 4);
        gbassert(v4 == std::vector{ 1,111,11,11,11,2,9 });
        v4.resize(9);
        gbassert(v4 == std::vector{ 1,111,11,11,11,2,9,0,0 });
        v4.resize(5);
        gbassert(v4 == std::vector{ 1,111,11,11,11 });

        // serialization
        omem_archive<static_vector<char, 1000>> ma;
        ma(v, v1, v2, v3, v4);
        v.clear();
        v1.clear();
        v2.clear();
        v3.clear();
        v4.clear();
        imem_archive<static_vector<char, 1000>> ima(std::move(ma));
        ima(v, v1, v2, v3, v4);
        gbassert(v == std::vector{ 1,2,3,4,5 });
        gbassert(v1.empty());
        gbassert(v2.empty());
        gbassert(v3 == std::vector{ 5, 5, 5, 10 });
        gbassert(v4 == std::vector{ 1,111,11,11,11 });
    }

    GB_TEST(yadro, tensor_test)
    {
        using namespace tensor_operators;
        static_assert(tensor_c< tensor<int, 2, 2>>);
        static_assert(tensor_c< tensor<int>>);

        tensor<int, 2, 2> t0{ 1, 2, 3, 4 };
        gbassert(t0(0, 0) == 1);
        gbassert(t0(1, 0) == 2);
        gbassert(t0(0, 1) == 3);
        gbassert(t0(1, 1) == 4);

        tensor<int, 1, 2, 3> t123{};
        tensor<int> t(1, 2, 3);
        gbassert(t123.index_of(0, 1, 2) == t.index_of(0, 1, 2));
        t(0, 1, 2) = 1;
        t(0, 0, 0) = 2;
        tensor<int> t2(t123);
        gbassert(t2 == t123);
        t2(0, 0, 0) = 3;
        t123 = t2;
        gbassert(t2 == t123);
        tensor<int, 1, 2, 3> t3;
        t3 = t2;
        gbassert(t2 == t3);
        gbassert(t123 == t3);

        // test serialization
        omem_archive<> ma;
        ma(t0, t);
        imem_archive im(std::move(ma));
        auto [t01, t1] = deserialize< tensor<int, 2, 2>, tensor<int>>(im);
        gbassert(t0 == t01);
        gbassert(t == t1);
    }

    GB_TEST(yadro, matrix_test)
    {
        using namespace tensor_operators;
        static_assert(tensor_c< tensor<int, 2, 2>>);
        static_assert(tensor_c< tensor<int>>);

        matrix<double, 2, 3> m{};
        m(0, 0) = 0;
        m(1, 0) = 1;
        m(0, 1) = 0;
        m(1, 1) = 0;
        matrix<double> m23(2, 3);
        m23(0, 0) = 0;
        m23(1, 0) = 1;

        gbassert(m.index_of(0, 0) == m23.index_of(0, 0));
        gbassert(m.index_of(1, 0) == m23.index_of(1, 0));
        gbassert(m.index_of(0, 1) == m23.index_of(0, 1));
        gbassert(m.index_of(1, 1) == m23.index_of(1, 1));
        gbassert(m == m23);
        m23(1, 1) = 11;
        m = m23;
        gbassert(m == m23);

        matrix<double> m1(m);
        gbassert(m == m1);
        matrix<double, 2, 3> m2(m);
        gbassert(m == m2);

        matrix<double, 2, 2> m3;
        m3(0, 0) = 1;
        m3(0, 1) = 1;
        m3(1, 0) = 2;
        m3(1, 1) = 5;
        gbassert(minor_view(m3, 0, 0)(0, 0) == 5);
        auto mv = minor_view(m3, 0, 0);
        static_assert(matrix_c<decltype(mv)>);
        gbassert(determinant(m3) == 3);

        auto solution = solve(m3, matrix<double, 2, 1>{2., 7.});
        gbassert(solution == matrix<double, 2, 1>{1., 1.});

        auto inverted = invert(m3);
        gbassert(almost_equal(inverted, matrix<double, 2, 2>{1.6667, -0.6667, -0.3333, 0.3333}, 0.001));
        gbassert(almost_equal(m3 * inverted, identity_matrix<double>(2), 0.001));

        matrix<double, 3, 3> m4{
            1, 1, 2,
            1, 2, -1,
            1, 5, 3
        };
        auto solution4 = solve(m4, column_t<double, 3>{3, 8, 4});
        gbassert(solution4 == column_t<double, 3>{ 1, 1, 1 });
        gbassert(determinant(m4) == 13);

        m4.transform([](auto&& value)
            {
                return value == 1 ? 10 : value;
            });
        gbassert(m4 == matrix<double, 3, 3>{
            10, 10, 2,
                10, 2, -1,
                10, 5, 3});

        gbassert(transform([](auto&& v) { return -v; }, get_row(m4, 1)) == row_t<double, 3>{ -10, -2, -5});

        gbassert(transform([](auto&& value1, auto&& value2) { return value1 + value2; }, m4, matrix<double, 3, 3>{
            1, 3, 5,
                2, 4, 6,
                7, 8, 9}) == matrix<double, 3, 3>{
            11, 13, 7,
                12, 6, 5,
                17, 13, 12}
        );

        gbassert(matrix<int, 2, 2>{
            1, 2,
                3, 4}
        + matrix<int, 2, 2> {
            0, -2,
                -3, -3}
        == identity_matrix<int>(2));

        gbassert(matrix<int, 2, 2>{2, 0, 0, 2} == identity_matrix<int>(2) * 2);
        gbassert(matrix<int, 2, 2>{2, 0, 0, 2} == 2 * identity_matrix<int>(2));
        gbassert(matrix<int, 2, 2>{2, 0, 0, 2} / 2 == identity_matrix<int>(2));
    }
}
