//-----------------------------------------------------------------------------
//  Copyright (C) 2024, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#pragma once
#include "gbwin.h"
#include "tuple_functions.h"
#include "gblog.h"
#include "misc.h"
#include "../archive/archive.h"
#include "../async/threadpool.h"

#include <string>

#ifdef GBWINDOWS

namespace gb::yadro::util
{
    struct owinpipe_stream;
    struct iwinpipe_stream;
    using owinpipe_archive = gb::yadro::archive::archive<owinpipe_stream, gb::yadro::archive::archive_format_t::custom>;
    using iwinpipe_archive = gb::yadro::archive::archive<iwinpipe_stream, gb::yadro::archive::archive_format_t::custom>;

    template<class ...Functions> struct winpipe_server_t;

    constexpr auto max_pipe_buffer_size = 16384u;// 16k, Win32 API gives no guarantees about the max buffer size
    constexpr auto chunk_size = 1024u;

    //----------------------------------------------------------------------------------------------
    struct owinpipe_stream
    {
        using char_type = char;
        explicit owinpipe_stream(HANDLE pipe) : _pipe(pipe) {}

        void write(const char_type* c, std::streamsize size)
        {
            gbassert(size < max_pipe_buffer_size);

            if (DWORD bytes_written{};
                not WriteFile(_pipe, c, (DWORD)size, &bytes_written, nullptr) || bytes_written != size)
                throw util::exception_t("owinpipe_stream failed to write to pipe: ", GetLastError());

            // write in chunks
            char next_chunk[] = "next chunk\0";

            for (std::streamsize sent_bytes = 0; sent_bytes < size;)
            {
                // read request for the next chunk
                if (DWORD bytes_read{};
                    not ReadFile(_pipe, next_chunk, (DWORD)sizeof(next_chunk), &bytes_read, nullptr)
                    || bytes_read != (DWORD)sizeof(next_chunk))
                    throw util::exception_t("owinpipe_stream failed to receive next chunk request: ", GetLastError());

                auto bytes_to_send = size - sent_bytes > chunk_size ? chunk_size : size - sent_bytes;

                if (DWORD bytes_written{};
                    not WriteFile(_pipe, &c[sent_bytes], (DWORD)bytes_to_send, &bytes_written, nullptr)
                    || bytes_written != bytes_to_send)
                    throw util::exception_t("owinpipe_stream failed to write chunk to pipe: ", GetLastError());
                else
                    sent_bytes += bytes_written;
            }
        }

    private:
        HANDLE _pipe = INVALID_HANDLE_VALUE;
    };


    //----------------------------------------------------------------------------------------------
    struct iwinpipe_stream
    {
        using char_type = char;
        explicit iwinpipe_stream(HANDLE pipe) : _pipe(pipe) {}

        void read(char_type* c, std::streamsize size)
        {
            // read in chunks
            char next_chunk[] = "next chunk\0";

            for (std::streamsize received_bytes = 0; received_bytes < size; gbassert(received_bytes <= size))
            {
                // request the next chunk
                if (DWORD bytes_written{};
                    not WriteFile(_pipe, next_chunk, (DWORD)sizeof(next_chunk), &bytes_written, nullptr)
                    || bytes_written != (DWORD)sizeof(next_chunk))
                    throw util::exception_t("iwinpipe_stream failed to request next chunk: ", GetLastError());

                if (DWORD bytes_read{};
                    not ReadFile(_pipe, &c[received_bytes], chunk_size, &bytes_read, nullptr) || bytes_read == 0)
                    throw util::exception_t("iwinpipe_stream failed to read chunk from pipe: ", GetLastError());
                else
                    received_bytes += bytes_read;
            }
        }

    private:
        HANDLE _pipe = INVALID_HANDLE_VALUE;
    };

    //----------------------------------------------------------------------------------------------
    template<class T, class Functions>
    concept server_function_c = std::convertible_to< T, std::tuple<std::string, Functions>>;
    //----------------------------------------------------------------------------------------------
    template<class ...Functions>
    struct winpipe_server_t
    {
        winpipe_server_t(const std::wstring& pipename, std::tuple<std::string, Functions>&&... actions);
        ~winpipe_server_t()
        {
            if (_pipe != INVALID_HANDLE_VALUE)
            {
                FlushFileBuffers(_pipe);
                DisconnectNamedPipe(_pipe);
                CloseHandle(_pipe);
            }
        }

        void run();
        auto run(async::threadpool<>&);

    private:
        std::wstring _pipename; // Win10, v 1709 "\\\\.\\pipe\\LOCAL\\"
        HANDLE _pipe = INVALID_HANDLE_VALUE;
        //static util::logger _log{ std::cout };
        std::tuple<std::tuple<std::string, Functions>...> _actions;

        template<class T> requires(archive::is_serializable_v<iwinpipe_archive, std::remove_cvref_t<T>>)
            void receive(T& t) const
        {
            iwinpipe_archive a;
            a(t);
        }

        template<class T> requires(archive::is_serializable_v<owinpipe_archive, std::remove_cvref_t<T>>)
            void send(const T& t) const
        {
            owinpipe_archive a;
            a(t);
        }
    };

    //----------------------------------------------------------------------------------------------
    struct winpipe_client_t
    {

    };

    //----------------------------------------------------------------------------------------------
    // https://learn.microsoft.com/en-us/windows/win32/ipc/multithreaded-pipe-server
    template<class ...Functions>
    inline winpipe_server_t<Functions...>::winpipe_server_t(const std::wstring& pipename,
        std::tuple<std::string, Functions>&&... actions)
        : _pipename(pipename), _actions{ std::tuple{ actions... } }
    {
        const DWORD buf_size = 1024; // unsigned long
        HANDLE hPipe = INVALID_HANDLE_VALUE;

        _pipe = CreateNamedPipe(
                    _pipename.c_str(),             // pipe name 
                    PIPE_ACCESS_DUPLEX,       // read/write access 
                    PIPE_TYPE_MESSAGE |       // message type pipe 
                    PIPE_READMODE_MESSAGE |   // message-read mode 
                    PIPE_WAIT,                // blocking mode 
                    PIPE_UNLIMITED_INSTANCES, // max. instances (255)
                    buf_size,                  // output buffer size (default buffer size for Windows named pipes is 64 KB, above not guaranteed)
                    buf_size,                  // input buffer size 
                    0,                        // client time-out 
                    NULL);                    // default security attribute             

        if (hPipe == INVALID_HANDLE_VALUE)
        {
            std::string str_name(_pipename.size(), 0);
            std::transform(_pipename.begin(), _pipename.end(), str_name.begin(), [](auto wc) { return static_cast<char>(wc); });
            throw util::exception_t("failed to create pipe: " + str_name, GetLastError());
        }

        // connect to client, ERROR_PIPE_CONNECTED means client connected before ConnectNamedPipe called
        // ConnectNamedPipe blocks indefinitely until connected or failed
        if (auto is_connected = ConnectNamedPipe(hPipe, nullptr) || GetLastError() == ERROR_PIPE_CONNECTED; !is_connected)
        {
            throw util::exception_t("failed to connect to pipe: ", GetLastError());
        }
    }

    //----------------------------------------------------------------------------------------------
    template<class ...Functions>
    inline void winpipe_server_t<Functions...>::run()
    {
        auto send_n = [&]<auto N>()
        {
            if (N > sizeof...(Functions))
                throw util::exception_t("invalid request", N);

            auto&& action = std::get<N>(_actions);
            typename lambda_traits<std::remove_cvref_t<decltype(action)>>::Args t;
            receive(t);
            send(std::invoke(action, t));
        };

        for(auto action_id = receive<std::uint32_t>(); action_id < sizeof...(Functions); action_id = receive<std::uint32_t>())
        {
            switch (action_id)
            {
            case 0: send<0>(); break;
            case 1: send<1>(); break;
            case 2: send<2>(); break;
            case 3: send<3>(); break;
            case 4: send<4>(); break;
            case 5: send<5>(); break;
            case 6: send<6>(); break;
            case 7: send<7>(); break;
            case 8: send<8>(); break;
            case 9: send<9>(); break;
            case 10: send<10>(); break;
            case 11: send<11>(); break;
            case 12: send<12>(); break;
            case 13: send<13>(); break;
            case 14: send<14>(); break;
            case 15: send<15>(); break;
            case 16: send<16>(); break;
            case 17: send<17>(); break;
            case 18: send<18>(); break;
            case 19: send<19>(); break;
            default: throw util::exception_t{ "invalid request: ", action_id };
            }
        }
    }
}

#endif
