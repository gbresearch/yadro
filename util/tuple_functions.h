//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2024, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#pragma once
#include <tuple>
#include <concepts>
#include <sstream>
#include <type_traits>
#include <functional>
#include <utility>

namespace gb::yadro::util
{
    //-------------------------------------------------------------------------
    // tuple functions
    //-------------------------------------------------------------------------

    //-------------------------------------------------------------------------
    // conver multile tuples to string in format {x,x,x}
    // std::ignore values are skipped
    auto tuple_to_string(const auto& ... tuples)
    {
        std::ostringstream os;
        auto write_one = [&](const auto& t)
            {
                auto write_value = [&](const auto& v)
                    {
                        if constexpr (!std::is_same_v< std::remove_cvref_t<decltype(v)>,
                            std::remove_cvref_t<decltype(std::ignore)>>)
                            os << v;
                    };

                std::apply([&](const auto& v1, const auto& ...v) mutable
                    {
                        os << '{';
                        write_value(v1);
                        ((os << ',', write_value(v)), ...);
                        os << '}';
                    }, t);
            };

        if (sizeof...(tuples) != 0)
            (write_one(tuples), ...);

        return os.str();
    }


    template<std::size_t ...I>
    concept is_sorted_idx = std::ranges::is_sorted(std::array<std::size_t, sizeof...(I)>{I...});

    template<std::size_t N, std::size_t...I>
    consteval auto offset_sequence(std::index_sequence<I...>) { return std::index_sequence<(N + I)...>{}; }

    template<std::size_t ...I, std::size_t ...J>
    consteval auto make_sequence(std::index_sequence<I...>, std::index_sequence<J...>)
    {
        return std::tuple{ offset_sequence<I>(std::make_index_sequence<(J - I)>{})... };
    }

    template<std::size_t Last, std::size_t First, std::size_t ...I>
    requires(is_sorted_idx<First, I...>)
    consteval auto make_sequence(std::index_sequence<First, I...>)
    {
        return make_sequence(std::index_sequence<First, I...>{}, std::index_sequence<I..., Last>{});
    }

    // MSVC 19.latest compiler fails with consteval
    template<size_t...I>
    constexpr auto get_from_sequence(auto&& t, std::index_sequence<I...>)
    {
        return std::tuple{ std::get<I>(t)... };
    }

    //-------------------------------------------------------------------------
    // split tuple by indexes (must be sorted)
    // returns a tuple of multiple tuples cut by supplied indexes, counting from 0
    // for example: tuple_split<2,3,5>(tuple{1,2,3,4,5,6,7}) --> {{1,2},{3},{4,5},{6,7}}
    // MSVC 19.latest compiler fails with consteval

    template<size_t...I>
    requires(is_sorted_idx<I...>)
    constexpr auto tuple_split(auto&& t)
    {
        constexpr auto size = std::tuple_size_v<std::remove_cvref_t<decltype(t)>>;
        static_assert(((I > 0) && ...));
        static_assert(((I < size) && ...));
        return std::apply([&](auto&&...seq)
            {
                return std::tuple{ get_from_sequence(std::forward<decltype(t)>(t), seq)... };
            }, make_sequence<size>(std::index_sequence<0, I...>{}));
    }
    
    //-------------------------------------------------------------------------
    // making a sub-tuple from tuple-like type in index range [From, To)

    template<std::size_t From, std::size_t To>
    constexpr auto subtuple(auto&& t)
    {
        using tuple_type = std::remove_cvref_t<decltype(t)>;
        static_assert(From >= 0 && From < To && To <= std::tuple_size_v<tuple_type>);
        return get_from_sequence(std::forward<tuple_type>(t),
            offset_sequence<From>(std::make_index_sequence<(To - From)>{}));
    }

    //-------------------------------------------------------------------------
    // making a sub-tuple from tuple-like type in index range [From, Tuple-Size)
    template<std::size_t From>
    constexpr auto subtuple(auto&& t)
    {
        using tuple_type = std::remove_cvref_t<decltype(t)>;
        return subtuple<From, std::tuple_size_v<tuple_type>>(std::forward<tuple_type>(t));
    }

    //-------------------------------------------------------------------------
    // call specified functions for each element of the tuple/pair/array/subrange
    // returning a tuple of return values from each function call
    // if function returns void then std::ignore will be used in returned tuple
    // std::ignore can be used instead of a function in order to ignore the value
    // note: function arguments evaluation order is unspecified and so are side effects
    //-------------------------------------------------------------------------
    inline auto tuple_foreach(auto&& tup, auto&&... fn)
        requires(std::tuple_size<std::remove_cvref_t<decltype(tup)>>::value == sizeof ...(fn))
    {
        auto call = [](auto&& fn, auto&& val)
            {
                if constexpr (std::is_same_v<std::remove_cvref_t<decltype(fn)>,
                    std::remove_cvref_t<decltype(std::ignore)>>)
                    return std::ignore;
                else if constexpr (std::is_same_v<std::invoke_result_t<decltype(fn), decltype(val)>, void>)
                {
                    std::invoke(std::forward<decltype(fn)>(fn), std::forward<decltype(val)>(val));
                    return std::ignore;
                }
                else
                    return std::invoke(std::forward<decltype(fn)>(fn), std::forward<decltype(val)>(val));
            };

        return std::apply([&](auto&&...args)
            {
                return std::tuple(call(std::forward<decltype(fn)>(fn), std::forward<decltype(args)>(args))...);
            }, std::forward<decltype(tup)>(tup));
    }

    //-------------------------------------------------------------------------
    // create a new tuple with the values from tuple corresponding to indexes
    template<std::size_t... Indexes>
    inline auto tuple_select(auto&& tup)
    {
        return std::tuple(std::get<Indexes>(tup)...);
    }

    //-------------------------------------------------------------------------
    // create a new tuple with all std::ignore values removed
    inline auto tuple_remove_ignored(auto&& tup)
    {
        auto make_t = [](auto&& v)
            {
                if constexpr (std::is_same_v< std::remove_cvref_t<decltype(v)>,
                    std::remove_cvref_t<decltype(std::ignore)>>)
                    return std::tuple<>{};
                else
                    return std::tuple{ std::forward<decltype(v)>(v) };
            };
        return std::apply([&](auto&& ...v)
            {
                return std::tuple_cat(make_t(std::forward<decltype(v)>(v))...);
            }, std::forward<decltype(tup)>(tup));
    }

    //-------------------------------------------------------------------------
    // transform multiple tuples to another tuple where transform_fn is called on each element of the tuples in lockstep
    // requires all tuples to be the same size
    auto tuple_transform(auto&& transform_fn, auto&& t, auto&& ...ts)
        requires ((sizeof ...(ts) == 0 ||
        ((std::tuple_size<std::remove_cvref_t<decltype(t)>>{} == std::tuple_size<std::remove_cvref_t<decltype(ts)>>{})
        && ...)) && std::invocable<decltype(transform_fn), decltype(std::get<0>(t)), decltype(std::get<0>(ts))...>)
    {
        auto get_n = [&]<std::size_t N>(std::index_sequence<N>)
        {
            return transform_fn(std::get<N>(std::forward<decltype(t)>(t)), std::get<N>(std::forward<decltype(ts)>(ts))...);
        };

        auto get_tup = [&]<std::size_t ...N>(std::index_sequence<N...>)
        {
            return std::tuple(get_n(std::index_sequence<N>{})...);
        };
        
        constexpr auto size = std::tuple_size<std::remove_cvref_t<decltype(t)>>{};

        return get_tup(std::make_index_sequence<size>{});
    }

    //-------------------------------------------------------------------------
    // apply reduce_fn to a tuple which is transformed using transfrom_fn
    inline auto tuple_transform_reduce(auto&& transform_fn, auto&& reduce_fn, auto&& t) 
        requires requires { std::get<0>(t); }
    {
        return std::apply(std::forward<decltype(reduce_fn)>(reduce_fn), tuple_transform(
            std::forward<decltype(transform_fn)>(transform_fn), std::forward<decltype(t)>(t)));
    }

    //-------------------------------------------------------------------------
    // returns min value of all elements of the specified tuples (must be comparable)
    inline auto tuple_min(auto&& ...t)
    {
        return std::min({ std::apply([](auto&& ...val) { return std::min({ val... }); }, t)... });
    }

    //-------------------------------------------------------------------------
    // returns max value of all elements of the specified tuples (must be comparable)
    inline auto tuple_max(auto&& ...t)
    {
        return std::max({ std::apply([](auto&& ...val) { return std::max({ val... }); }, t)... });
    }

#if defined(clang_p1061)
    //-------------------------------------------------------------------------
    // return member count of a class
    constexpr auto class_member_count(auto&& t)
    {
        auto&& [...x] = std::forward<decltype(t)>(t);
        return sizeof...(x);
    }
    
    //-------------------------------------------------------------------------
    // create a tuple from the members of class
    constexpr auto class_to_tuple(auto&& t)
    {
        auto&& [...x] = std::forward<decltype(t)>(t);
        return std::tuple{ std::forward<decltype(x)>(x)...};
    }
#endif

    //-------------------------------------------------------------------------
    namespace detail
    {
        template<class T> concept aggregate_type = std::is_aggregate_v<T>;
        struct filler_t
        {
            template<class T> requires(!aggregate_type<T>) constexpr operator T& ();
            template<class T> requires(!aggregate_type<T>) constexpr operator T && ();
        };
    }

    //-------------------------------------------------------------------------
    // return member count of an aggregate
    template<detail::aggregate_type T>
    constexpr auto aggregate_member_count(auto&& ...filler)
    {
        if constexpr (requires{ T{ filler... }; })
            return aggregate_member_count<T>(detail::filler_t{}, filler...);
        else
        {
            static_assert(sizeof...(filler), "unsupported type");
            return sizeof...(filler) - 1;
        }
    }

    //-------------------------------------------------------------------------
    // create a tuple from aggregate
    template<detail::aggregate_type T, auto N = aggregate_member_count<T>()>
    constexpr auto aggregate_to_tuple(T&& t)
    {
        static_assert(N > 0 && N < 11);

        if constexpr(N == 1)
        {
            auto&& [x] = std::forward<T>(t);
            return std::tuple(std::forward<decltype(x)>(x));
        }
        else if constexpr (N == 2)
        {
            auto&& [x1, x2] = std::forward<T>(t);
            return std::tuple(std::forward<decltype(x1)>(x1), std::forward<decltype(x2)>(x2));
        }
        else if constexpr (N == 3)
        {
            auto&& [x1, x2, x3] = std::forward<T>(t);
            return std::tuple(std::forward<decltype(x1)>(x1), std::forward<decltype(x2)>(x2), std::forward<decltype(x3)>(x3));
        }
        else if constexpr (N == 4)
        {
            auto&& [x1, x2, x3, x4] = std::forward<T>(t);
            return std::tuple(std::forward<decltype(x1)>(x1), std::forward<decltype(x2)>(x2), std::forward<decltype(x3)>(x3), std::forward<decltype(x4)>(x4));
        }
        else if constexpr (N == 5)
        {
            auto&& [x1, x2, x3, x4, x5] = std::forward<T>(t);
            return std::tuple(std::forward<decltype(x1)>(x1), std::forward<decltype(x2)>(x2), std::forward<decltype(x3)>(x3), std::forward<decltype(x4)>(x4), 
                std::forward<decltype(x5)>(x5));
        }
        else if constexpr (N == 6)
        {
            auto&& [x1, x2, x3, x4, x5, x6] = std::forward<T>(t);
            return std::tuple(std::forward<decltype(x1)>(x1), std::forward<decltype(x2)>(x2), std::forward<decltype(x3)>(x3), std::forward<decltype(x4)>(x4),
                std::forward<decltype(x5)>(x5), std::forward<decltype(x6)>(x6));
        }
        else if constexpr (N == 7)
        {
            auto&& [x1, x2, x3, x4, x5, x6, x7] = std::forward<T>(t);
            return std::tuple(std::forward<decltype(x1)>(x1), std::forward<decltype(x2)>(x2), std::forward<decltype(x3)>(x3), std::forward<decltype(x4)>(x4),
                std::forward<decltype(x5)>(x5), std::forward<decltype(x6)>(x6), std::forward<decltype(x7)>(x7));
        }
        else if constexpr (N == 8)
        {
            auto&& [x1, x2, x3, x4, x5, x6, x7, x8] = std::forward<T>(t);
            return std::tuple(std::forward<decltype(x1)>(x1), std::forward<decltype(x2)>(x2), std::forward<decltype(x3)>(x3), std::forward<decltype(x4)>(x4),
                std::forward<decltype(x5)>(x5), std::forward<decltype(x6)>(x6), std::forward<decltype(x7)>(x7), std::forward<decltype(x8)>(x8));
        }
        else if constexpr (N == 9)
        {
            auto&& [x1, x2, x3, x4, x5, x6, x7, x8, x9] = std::forward<T>(t);
            return std::tuple(std::forward<decltype(x1)>(x1), std::forward<decltype(x2)>(x2), std::forward<decltype(x3)>(x3), std::forward<decltype(x4)>(x4),
                std::forward<decltype(x5)>(x5), std::forward<decltype(x6)>(x6), std::forward<decltype(x7)>(x7), std::forward<decltype(x8)>(x8),
                std::forward<decltype(x9)>(x9));
        }
        else if constexpr (N == 10)
        {
            auto&& [x1, x2, x3, x4, x5, x6, x7, x8, x9, x10] = std::forward<T>(t);
            return std::tuple(std::forward<decltype(x1)>(x1), std::forward<decltype(x2)>(x2), std::forward<decltype(x3)>(x3), std::forward<decltype(x4)>(x4),
                std::forward<decltype(x5)>(x5), std::forward<decltype(x6)>(x6), std::forward<decltype(x7)>(x7), std::forward<decltype(x8)>(x8),
                std::forward<decltype(x9)>(x9), std::forward<decltype(x10)>(x10));
        }
    }
}
