//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2024, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#include "../util/gbtest.h"
#include "../util/misc.h"
#include "../container/graph.h"
#include "../container/static_string.h"
#include "../container/static_vector.h"
#include "../container/tree.h"
#include "../archive/archive.h"
#include <vector>

namespace
{
    using namespace gb::yadro::container;
    using namespace gb::yadro::util;
    using namespace gb::yadro::archive;

    GB_TEST(yadro, tree_test)
    {
        indexed_tree<int> tree1;
        gbassert(tree1.get_value(0) == 0);
        auto c1 = tree1.insert_child(0, 1);
        gbassert(tree1.get_value(c1) == 1);
        auto c2 = tree1.insert_child(0, 2);
        gbassert(tree1.get_value(c2) == 2);
        gbassert(tree1.get_sibling(c2) == c1);
        auto c3 = tree1.insert_after_sibling(c2, 3);
        gbassert(tree1.get_value(c3) == 3);
        gbassert(tree1.get_sibling(c2) == c3);
        tree1.reverse_children(0);
        gbassert(tree1.get_sibling(c1) == c3);
        gbassert(tree1.get_sibling(c2) == tree1.invalid_index);
        gbassert(tree1.get_sibling(c3) == c2);
        tree1.clear();
        gbassert(tree1.empty());

        indexed_tree<int> tree2(123);
        gbassert(tree2.get_value(0) == 123);
        tree2.insert_child(0, 1231);
        tree2.insert_child(0, 1232);
        tree2.insert_child(0, 1233);
        tree2.foreach_child(0, [&](auto id)
            {
                gbassert(id > 0 && id < 4);
                switch (id)
                {
                case 1: gbassert(tree2.get_value(id) == 1231); break;
                case 2: gbassert(tree2.get_value(id) == 1232); break;
                case 3: gbassert(tree2.get_value(id) == 1233); break;
                }
            });

        omem_archive<> ma;
        ma(tree2);
        imem_archive ima(std::move(ma));
        ima(tree1);
        tree1.foreach_child(0, [&](auto id)
            {
                gbassert(id > 0 && id < 4);
                switch (id)
                {
                case 1: gbassert(tree2.get_value(id) == 1231); break;
                case 2: gbassert(tree2.get_value(id) == 1232); break;
                case 3: gbassert(tree2.get_value(id) == 1233); break;
                }
            });
    }

    GB_TEST(yadro, graph_test)
    {
        // [0]->[1]->[2]->[3]->[4]
        //  |------------>
        //        <--------|
        //  <------------------|

        // testing construction
        auto dump = R"(nodes 5:
[0]: { 3 1 }, value: 0
[1]: { 2 }, value: 0
[2]: { 3 }, value: 0
[3]: { 4 1 }, value: 0
[4]: { 0 }, value: 0
edges 7:
[0]: {from: 0, to: 1, in_sibling: x, out_sibling: x}
[1]: {from: 1, to: 2, in_sibling: x, out_sibling: x}
[2]: {from: 2, to: 3, in_sibling: x, out_sibling: x}
[3]: {from: 0, to: 3, in_sibling: 2, out_sibling: 0}
[4]: {from: 3, to: 1, in_sibling: 0, out_sibling: x}
[5]: {from: 3, to: 4, in_sibling: x, out_sibling: 4}
[6]: {from: 4, to: 0, in_sibling: x, out_sibling: x}
)";
        graph<int> g(5, 0);
        auto e01 = g.add_edge(0, 1);
        auto e12 = g.add_edge(1, 2);
        auto e23 = g.add_edge(2, 3);
        auto e03 = g.add_edge(0, 3);
        auto e31 = g.add_edge(3, 1);
        auto e34 = g.add_edge(3, 4);
        auto e40 = g.add_edge(4, 0);
        std::ostringstream os;
        g.dump(os);
        gbassert(os.str() == dump);

        // testing serialization
        omem_archive<> ma;
        ma(g);
        imem_archive ima(std::move(ma));
        graph<int> g1(ima);
        gbassert(g == g1);
    }
}
