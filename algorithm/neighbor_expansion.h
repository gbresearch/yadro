//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2024, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#pragma once
#include <map>
#include <set>
#include <functional>
#include <tuple>
#include <chrono>
#include <random>
#include <optional>

#include "../util/gberror.h"
#include "../util/misc.h"
#include "../async/threadpool.h"

namespace gb::yadro::algorithm
{
    // neighbor expansion optimization algorithm, minimizing target function
    template<class Fn, class ...Types>
    struct neighbor_expansion
    {
        neighbor_expansion(Fn target_fn, std::tuple<Types, Types> ... min_max)
            requires (std::invocable<Fn, Types...> && ... && std::convertible_to<double, Types>)
            : _target_fn(target_fn), _min_max_params(min_max...)
        { }

            auto optimize(auto&& duration, std::size_t convergence_count = -1) const;
            auto optimize(gb::yadro::async::threadpool<>& tpool, auto && duration) const;

    private:
        Fn _target_fn;
        std::tuple<std::tuple<Types, Types>...> _min_max_params;
    };

    template<class Fn, class ...Types>
    auto neighbor_expansion<Fn, Types...>::optimize(auto&& duration, std::size_t convergence_count) const
    {
        auto start_time = std::chrono::high_resolution_clock::now();
        using target_t = std::invoke_result_t<Fn, Types...>;
        std::set<std::size_t> visited; // to avoid linear search through _opt_set
        std::multimap<target_t, std::tuple<Types...>> opt_map; // target functions calculated

        std::random_device rd;
        std::mt19937 gen(rd());

        auto initial_params = [&]
            {
                return gb::yadro::util::tuple_transform([&](auto&& tup)
                    {
                        auto [min_value, max_value] = tup;
                        std::uniform_real_distribution<> dist(min_value, max_value);
                        return dist(gen);
                    }, _min_max_params);
            };

        auto stddev_tuple = gb::yadro::util::tuple_transform([&](auto&& min_max)
            {
                return std::abs(std::get<0>(min_max) + std::get<1>(min_max)) / 8;
            }, _min_max_params);


        auto next_random = [&](auto&& rand_params) {
            return gb::yadro::util::tuple_transform(
                [&](auto&& param, auto&& min_max, auto&& stddev)
                {
                    std::normal_distribution<> dist(param, stddev);
                    return std::max(std::min(dist(gen), std::get<1>(min_max)), std::get<0>(min_max));
                }, rand_params, _min_max_params, stddev_tuple);
            };

        for (auto [rand_params, target] = std::tuple(initial_params(), std::numeric_limits<double>::infinity());
            convergence_count != 0 && std::chrono::high_resolution_clock::now() - start_time < duration;
            rand_params = next_random(rand_params))
        {
            if (visited.insert(gb::yadro::util::make_hash(rand_params)).second)
            {
                auto new_target = std::apply(_target_fn, rand_params);
                opt_map.emplace( new_target, rand_params );

                if (new_target < target)
                    target = new_target;
                else
                {   // not improved, use the best params from opt_map for the next jump
                    auto first = opt_map.begin();
                    gb::yadro::util::gbassert(first != opt_map.end());
                    auto first_rec = *first;
                    opt_map.erase(first);
                    opt_map.insert(first_rec); // move first_rec at the end of equal range
                    rand_params = first_rec.second;
                    --convergence_count;
                }
            }
        }

        return opt_map;
    }

    inline auto test_algo()
    {
        neighbor_expansion exp([](auto a, auto b) { return a + b; }, std::tuple(0.1, 1.0), std::tuple(1.0, 100.));
        using namespace std::chrono_literals;
        exp.optimize(1s);
    }
}