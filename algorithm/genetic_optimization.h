//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2024, Gene Bushuyev
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#pragma once
#include <map>
#include <set>
#include <functional>
#include <tuple>
#include <chrono>
#include <random>
#include <optional>
#include <ostream>

#include "../util/gberror.h"
#include "../util/misc.h"
#include "../util/tuple_functions.h"
#include "../util/gbmacro.h"
#include "../async/threadpool.h"

namespace gb::yadro::algorithm
{
    // neighbor expansion optimization algorithm, minimizing target function
    template<class Fn, class ...Types>
    struct genetic_optimization_t
    {
        genetic_optimization_t(Fn target_fn, std::tuple<Types, Types> ... min_max)
            requires (std::invocable<Fn, Types...> && ... && std::convertible_to<double, Types>)
        : _target_fn(target_fn), _min_max_params(min_max...)
        { }

        // performs genetic_optimization optimization, limited to time duration and max_tries
        // returns tuple(optimization_stats, optimization_map), keeping best max_history results in optimization_map 
        auto optimize(auto&& duration, std::size_t max_history = -1, std::size_t max_tries = -1) const;

    private:
        Fn _target_fn;
        std::tuple<std::tuple<Types, Types>...> _min_max_params;
    };
    
    // statistics for generic_optimization_t
    struct stats
    {
        std::size_t genetic_count;
        std::size_t mutation_count;
        std::size_t improvement_count;
        std::size_t repetition_count;
        std::size_t loop_count;
        std::size_t unique_param_count;

        friend auto& operator<< (std::ostream& os, const stats& s)
        {
            os << "loop count: " << s.loop_count
                << ", improvement count: " << s.improvement_count
                << ", genetic_count: " << s.genetic_count
                << ", mutation_count: " << s.mutation_count
                << ", unique params: " << s.unique_param_count
                << ", repetitions: " << (s.loop_count != 0 ? 100. * s.repetition_count / s.loop_count : 0) << "%"
                << "\n";
            return os;
        }
    };

    template<class Fn, class ...Types>
    auto genetic_optimization_t<Fn, Types...>::optimize(auto&& duration, std::size_t max_history, std::size_t max_tries) const
    {
        stats s{};
        using target_t = std::invoke_result_t<Fn, Types...>;
        std::set<std::size_t> visited; // to avoid linear search through _opt_set
        std::multimap<target_t, std::tuple<Types...>> opt_map; // target functions calculated

        std::random_device rd;
        std::mt19937 gen(rd());

        auto initial_params = [&]
            {
                return gb::yadro::util::tuple_transform([&](auto&& tup)
                    {
                        auto [min_value, max_value] = tup;
                        std::uniform_real_distribution<> dist((double)min_value, (double)max_value);
                        return static_cast<decltype(min_value)>(dist(gen));
                    }, _min_max_params);
            };

        // swap random fields from two parents
        std::normal_distribution<> genetic_distribution(0., 1.);
        std::uniform_real_distribution<> mutation_dist(0., 1.);

        auto next_genetic_mutation = [&](auto&& rand_params1, auto&& rand_params2) {
            return gb::yadro::util::tuple_transform(
                [&](auto&& param1, auto&& param2, auto&& min_max)
                {
                    using type_t = std::common_type_t<std::remove_cvref_t<decltype(param1)>, std::remove_cvref_t<decltype(param2)>>;
                    if (std::abs(genetic_distribution(gen)) > 1)
                    {
                        ++s.genetic_count;
                        return static_cast<type_t>(param2);
                    }
                    if (std::abs(genetic_distribution(gen)) > 1)
                    {
                        ++s.mutation_count;
                        return static_cast<type_t>(std::get<0>(min_max) + (std::get<1>(min_max) - std::get<0>(min_max)) * mutation_dist(gen));
                    }
                    else
                        return static_cast<type_t>(param1);
                }, rand_params1, rand_params2, _min_max_params);
            };


        for (auto [rand_params, target, start_time, last_target_update] =
            std::tuple(initial_params(), std::numeric_limits<double>::infinity(), std::chrono::high_resolution_clock::now(), std::chrono::high_resolution_clock::now());
            max_tries != 0 && std::chrono::high_resolution_clock::now() - start_time < duration
            && std::chrono::high_resolution_clock::now() - last_target_update < duration / 4;
            --max_tries, ++s.loop_count
            )
        {
            if (visited.insert(gb::yadro::util::make_hash(rand_params)).second)
            {
                ++s.unique_param_count;
                auto new_target = std::apply(_target_fn, rand_params);

                opt_map.emplace(new_target, rand_params);

                if (opt_map.size() > max_history)
                {
                    opt_map.erase(--opt_map.end());
                }

                if (new_target < target)
                {
                    target = new_target;
                    last_target_update = std::chrono::high_resolution_clock::now();
                    ++s.improvement_count;
                }
            }
            else
            {
                ++s.repetition_count;
            }

            // make genetic move
            gb::yadro::util::gbassert(!opt_map.empty());
                
            if (opt_map.size() > 1) // two best candidates breed
                rand_params = next_genetic_mutation(opt_map.begin()->second, (++opt_map.begin())->second);
            else
                rand_params = next_genetic_mutation(opt_map.begin()->second, opt_map.begin()->second);

            // move the first record to the end of equal range
            auto first = opt_map.begin();
            auto first_rec = *first;
            opt_map.erase(first);
            opt_map.insert(first_rec);
        }

        return std::tuple(s, opt_map);
    }
}
